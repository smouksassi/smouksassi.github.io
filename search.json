[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome to Samer’s Blog",
    "section": "",
    "text": "Welcome!\nThis is the first post in my personal blog. I have been working in the Modeling and Simulation field for 20 years and I started this blog to share my experience and how general solutions were developed to tackle specific and more general problems. I will keep this first post short and leave you with one of the dose exposure figures (using dummy data) that I developed for an FDA submission 15 years ago. Through out the years these visuals has evolved and are now part of my ggquickeda package that will be covered in future posts.\n\nThis visual include several components:\n\ndistribution of exposures (AUC) by dose level\nfor each distribution we show the percentage of it falling within a specific quantile of AUC\nin the middle we have a table detailing for Placebo and each Quartile: AUC bins, Total N of patients, N of Responders, and the observed Percentage of response\nin the upper panel a logistic fit and its 95%CI of the probability of clinical response versus AUC is shown.\nThe predicted response by dose level at the 10th, 25th, median,75th and 90th of exposure is shown and projected on the logistic curve\nThe predicted response is also projected on Y axis for head to head comparison across doses and to appreciate the saturation at the highest dose levels/exposures"
  },
  {
    "objectID": "posts/KMplots/index.html",
    "href": "posts/KMplots/index.html",
    "title": "Visualizing Time to Event Response",
    "section": "",
    "text": "In this post, I will continue with the exposure response theme. The previous blog post focused on Binary response outcomes. In today’s post I will illustrate how to explore and communicate time to event outcomes. First we start using a specialized geom from my ggquickeda package: geom_km(). Since this is a native ggplot2 geom it supports, aesthetics, faceting and margins, themings and anything else you expect from a ggplot2 object. Later on I cover the usage of the specialized ggkmrisktable function that support adding number at risk tables and more.\n\n\nCode\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggquickeda)\nlibrary(scales)\n\n options(ggplot2.discrete.colour =\n           list(c( \"#4682AC\",\"#FDBB2F\",\"#EE3124\" ,\"#336343\",\"#7059a6\", \"#803333\")))\n  options(ggplot2.discrete.fill =\n           list(c( \"#4682AC\",\"#FDBB2F\",\"#EE3124\" ,\"#336343\",\"#7059a6\", \"#803333\"))) \n  \nlung_long &lt;-  survival::lung |&gt;\n mutate(status = ifelse(status==1,0,1)) |&gt;\n gather(Endpoint,DV,status) |&gt;\n filter(!is.na(ph.karno),!is.na(pat.karno),!is.na(ph.ecog))|&gt;\n mutate(ph.ecog = ifelse(ph.ecog&gt;1,\"&gt;1\",\"1\"))\n\nggplot(lung_long, aes(\n                 time = time,\n               status = DV,\n               color  = ph.ecog,\n               linetype = ph.ecog,\n               fill = ph.ecog)) + \n  geom_kmband()+\n  geom_km() +\n  facet_grid(~ph.ecog,margin=\"ph.ecog\",\n             labeller = label_both)+\n  theme_bw(base_size = 16) +\n  labs(x=\"time of follow up\",y=\"Survival\")\n\n\n\n\n\n\n\n\n\nThis is a nice Kaplan-Meir plot that shows the K-M estimate by ecog status and both overlaid in the facet margin (all) panel. To include the effects of continuous variables, we will need to “bin” it. I will use age as a example predictor binning it by tertiles. Some nice features are outlined below:\n\nThis is a ggplot object and we can facet by any variable available in the dataset. Furthermore, I will illustrate the usage of the nice facet_nested from the ggh4x package to group facet strips that belong to the same level.\nThe plot is done in two ways using exptile as color and faceting variable which result in a facet margin (all) having the pooled estimate (all tertiles combined). Then, using exptile as color and faceting by an exact copy of it that we call exptile2. This tricks ggplot2 margins to overlay the three tertiles curves in the (all) panels.\n\n\n\nCode\nexposure_metric_plac_value &lt;- 0\n\nlung_long_metrics &lt;- lung_long %&gt;% \n  gather(expname,expvalue,age) |&gt;\n  group_by(Endpoint,expname) |&gt;\n  mutate( Q33 = quantile(expvalue[!expvalue %in% c(exposure_metric_plac_value)], 1/3, na.rm = TRUE), \n          Q66 = quantile(expvalue[!expvalue %in% c(exposure_metric_plac_value)], 2/3, na.rm = TRUE),\n          exptile = case_when(\n            expvalue == exposure_metric_plac_value ~ \"zero\", \n            expvalue &gt; exposure_metric_plac_value & expvalue &lt;= Q33 ~ \"T1\",\n            expvalue &gt; Q33 & expvalue &lt;= Q66 ~  \"T2\",\n            expvalue &gt; Q66 ~ \"T3\")\n  )\nlibrary(ggh4x)\nggplot(lung_long_metrics, aes(\n                 time = time,\n               status = DV,\n               color  = exptile,\n               linetype = ph.ecog,\n               fill = exptile)) + \n  geom_km() +\n  facet_nested( ph.ecog~ expname+ exptile,\n               labeller = label_both,margin = \"exptile\")+\n  theme_bw(base_size = 12) +\n  labs(x=\"time of follow up\",y=\"Survival\")\n\n\n\n\n\n\n\n\n\nCode\nlung_long_metrics$exptile2 &lt;- lung_long_metrics$exptile\n\nggplot(lung_long_metrics, aes(\n               time = time,\n               status = DV,\n               color  = exptile,\n               linetype = ph.ecog,\n               fill = exptile)) + \n  geom_km() +\n  facet_nested( ph.ecog ~ expname + exptile2,\n               labeller = label_both, margins = \"exptile2\")+\n  theme_bw(base_size = 12) +\n  labs(x=\"time of follow up\",y=\"Survival\")\n\n\n\n\n\n\n\n\n\nIt is common for these type of plots to present a transformation of the default which is the probability of not having the event . For example, changing it to cumulative hazard, or to event probability. It is also desirable to have a number at risk table underneath the plot. ggkmrisktable was written to facilitate and automate these tasks with several flexible options. First, we try to reproduce the last two plot. Notice how exptile2 is available automatically to enable different margins.\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  linetype = \"ph.ecog\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = TRUE, km_band = FALSE,\n  nrisk_table_variables = c(\"n.risk\")\n)+\n  facet_grid(ph.ecog~exptile,margin = \"exptile\")\n\n\n\n\n\n\n\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  linetype = \"ph.ecog\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = TRUE, km_band = FALSE,\n  nrisk_table_variables = c(\"n.risk\")\n)+\n  facet_grid(ph.ecog~exptile2,margin = \"exptile2\")\n\n\n\n\n\n\n\n\n\nThe plot above is busy and need to be simplified. Next, I show how to transform the event and I facet by ecog status.\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  linetype = \"ph.ecog\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  show_exptile_values = FALSE,\n  color_fill = \"exptile\",\n  xlab = \"time of follow up\",\n  ylab = \"Survival\",\n  nrisk_table_plot = TRUE,\n  nrisk_table_variables = c(\"n.risk\",\"n.censor\"),\n  nrisk_position_scaler = 0.2,\n  nrisk_position_dodge = 0.2,\n  nrisk_offset = 0,\n  km_trans = c(\"event\"),\n  km_ticks = FALSE, km_band = FALSE,\n  km_median_table_order = c(\"default\"),\n  facet_formula = ~ph.ecog)+\n  facet_nested( expname~ph.ecog,labeller = label_both)+\n  labs(x=\"time of follow up\",y=\"Survival\")\n\n\n\n\n\n\n\n\n\nThe use of additional options like showing the tertiles cutoffs, the median survival, controlling the order and the interval at which numbers at risk appear is shown next.\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  show_exptile_values = TRUE,\n  show_exptile_values_order = \"default\",\n  km_median =\"table\",\n  km_median_table_pos =\"right\",\n  km_median_table_order = \"default\",\n  color_fill = \"exptile\",\n  xlab = \"time of follow up\",\n  ylab = \"Survival\",\n  nrisk_table_plot = TRUE,\n  nrisk_table_variables = c(\"n.risk\",\"n.censor\"),\n  nrisk_position_scaler = 0.2,\n  nrisk_position_dodge = - 0.2,\n  nrisk_filterout0 = TRUE,\n  nrisk_table_breaktimeby = 50,\n  nrisk_offset = 0,\n  km_ticks = FALSE, km_band = TRUE,\n  km_trans = \"event\",\n  facet_formula = ~expname)\n\n\n\n\n\n\n\n\n\nWhile the function supports computing and printing p-values, I strongly, recommend that one run the statistical tests outside of the function. Make sure to document what test was done, on which data. Then we included the appropriate information using regular text/lable ggplot2 layer. An example, showing how to do an LRT on a cox fit is included.\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"exptile\",\n  linetype = \"exptile\", groupvar1 = \"none\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = FALSE,\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = TRUE,\n  facet_formula = expname ~ Endpoint )\n\n\n\n\n\n\n\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"ph.ecog\",\n  linetype = \"none\", groupvar1 = \"none\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = FALSE,\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = TRUE,\n  km_logrank_pvalue_cutoff = 0.001,\n  facet_formula = ~Endpoint)\n\n\n\n\n\n\n\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"exptile\",\n  linetype = \"exptile\", groupvar1 = \"ph.ecog\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = FALSE,\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = TRUE,\n  facet_formula = ~ph.ecog)\n\n\n\n\n\n\n\n\n\nOne would expect that the p-values shown in each panel are specific for the subset of panel data comparing the curves. While the case of single split, are clear, things get out of control fast when we have multiple splits/predictors and then deciding on what particular test we really want. Is it overall on all data ar within a specific strata/subset?\n\n\nCode\nlibrary(survival)\n#| message: false\n#| warning: false\n#| paged-print: true\n\n# overall \nsurvdiffexptile &lt;- survdiff(Surv(time, DV) ~ exptile,\n         data=lung_long_metrics)\npvalueexptile &lt;- pchisq(survdiffexptile$chisq, length(survdiffexptile$n)-1, lower.tail = FALSE)\npvalueexptile\n\n\n[1] 0.2132509\n\n\nCode\nsurvdiffph.ecog &lt;- survdiff(Surv(time, DV) ~ ph.ecog,\n         data=lung_long_metrics)\npvalueph.ecog &lt;- pchisq(survdiffph.ecog$chisq, length(survdiffph.ecog$n)-1, lower.tail = FALSE)\n\n\nsurvdiffexptileecoggt1 &lt;- survdiff(Surv(time, DV) ~ exptile,\n         data=lung_long_metrics %&gt;% \n           filter(ph.ecog!=\"1\"))\npvalueexptileecoggt1 &lt;- pchisq(survdiffexptileecoggt1$chisq, length(survdiffexptileecoggt1$n)-1, lower.tail = FALSE)\npvalueexptileecoggt1\n\n\n[1] 0.5051531\n\n\nCode\nsurvdiffexptileecogeq1 &lt;- survdiff(Surv(time, DV) ~ exptile,\n         data=lung_long_metrics %&gt;% \n           filter(ph.ecog==\"1\"))\npvalueexptileecogeq1 &lt;- pchisq(survdiffexptileecogeq1$chisq, length(survdiffexptileecogeq1$n)-1, lower.tail = FALSE)\npvalueexptileecogeq1\n\n\n[1] 0.5783551\n\n\nA global test across multiple variables that enter the survival equation, with or without interaction can be needed. For these, Idefinitely recommend to avoid using the automatic built-in p-values. The ggkmrisktable has groupvar1, groupvar2, and groupvar3 variables to give the user more control on how to “group” to test p-values but possibilities remain limited as compared to controlling the test with user-written code.\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"exptile\",\n  linetype = \"ph.ecog\", groupvar1 = \"none\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = FALSE,\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = TRUE,\n  facet_formula = ~Endpoint)\n\n\n\n\n\n\n\n\n\nCode\nsurvdiffph.ecogexptile &lt;- survdiff(Surv(time, DV) ~ ph.ecog+exptile, data=lung_long_metrics)\npvalueph.ecogexptile &lt;- pchisq(survdiffph.ecogexptile$chisq, length(survdiffph.ecogexptile$n)-1, lower.tail = FALSE)\npvalueph.ecogexptile\n\n\n[1] 0.002126178\n\n\nCode\nrmsmodel1 &lt;- coxph(Surv(time, DV) ~ 1, data       = lung_long_metrics)\nrmsmodel2 &lt;- coxph(Surv(time, DV) ~ ph.ecog*exptile, data = lung_long_metrics)\n#anova(rmsmodel1,rmsmodel2)\n\nandata &lt;- anova(rmsmodel1,rmsmodel2)\n\n\npvalueinformation = data.frame(p=andata[2,4],\n                               Endpoint=\"status\",\n                               Model=\"Surv(time, DV) ~ ph.ecog*age(tertiles)\",\n                               test=\"LRT\")\n\n\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"exptile\",\n  linetype = \"ph.ecog\", groupvar1 = \"none\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = FALSE,\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = FALSE,\n  facet_formula = ~Endpoint)+\n  geom_text(data=pvalueinformation,\n            aes(x=1000,y=0.2,label=paste0(\"Model: \",Model,\"\\n\",\n                                         test,\" test vs null model: \", scales::pvalue( p,add_p = TRUE,accuracy = 0.0001))),inherit.aes = FALSE,\n            hjust=1)\n\n\n\n\n\n\n\n\n\nCode\nggkmrisktable(\n  data = lung_long,\n  time = \"time\",\n  status = \"DV\",\n  endpoint = \"Endpoint\",\n  color_fill = \"exptile\",\n  linetype = \"ph.ecog\", groupvar1 = \"none\",\n  groupvar2 = \"none\",groupvar3 = \"none\",\n  exposure_metrics = c(\"age\"),\n  exposure_metric_split = c(\"tertile\"),\n  nrisk_table_plot = TRUE,nrisk_table_variables = c(\"n.risk\"),\n  km_ticks = FALSE, km_band = FALSE,\n  km_trans = \"event\",\n  km_logrank_pvalue = FALSE,\n  facet_formula = ~Endpoint)+\n  facet_grid(expname~ph.ecog)+\n  geom_text(data=pvalueinformation,\n            aes(x=1000,y=0.2,label=paste0(\"Model: \",Model,\"\\n\",\n                                         test,\" test vs null model: \", scales::pvalue( p,add_p = TRUE,accuracy = 0.0001))),inherit.aes = FALSE,\n            hjust=1)\n\n\n\n\n\n\n\n\n\nIn this post, I introduced some of the features available in ggkmrisktable. Since this is a regular ggplot2 plot the possibilities are limitless.\nIf you have any questions feel free to contact me on github."
  },
  {
    "objectID": "posts/etacovplots/index.html",
    "href": "posts/etacovplots/index.html",
    "title": "Exploring Covariate Plots",
    "section": "",
    "text": "In pharmacometrics analyses, it is common to plot the pharmacokinetic model parameters such as Clearance (CL) and Volume of distribution (Vd) versus continuous covariates such as Body Weight and Age and versus categorical covariates such as Sex, Race and renal function category. We will be using an example database that ships with the xpose.xtras package and explore out of the box available solutions and provide an alternative using custom functions plugged into the GGally’s package function ggduo.\n\n\nCode\nlibrary(xpose)\nlibrary(Certara.Xpose.NLME)       \nlibrary(xpose.xtras)       \nlibrary(tidyverse)\nlibrary(GGally)\nsource(\"ggpairs.fcn.r\")\n\nxpdb_x &lt;- xpdb_x %&gt;%\n  set_var_labels(AGE=\"Age\", MED1 = \"Digoxin\", .problem = 1) %&gt;%\n  set_var_units(AGE=\"yrs\")  %&gt;%\n  set_var_levels(SEX=lvl_sex(), MED1 = lvl_bin())\n\neta_vs_contcov(xpdb_x,etavar=ETA1, quiet=TRUE)\n\n\n\n\n\n\n\n\n\nThe Eta versus continuous covariates plot shows ETA(1) which is the random effect number one versus the values of the covariates shown in the facet strip of each panel. The run number, number of subjects, eta shrinkages for all eta not just ETA(1) are provided in the title and subtitle, as well as a caption “data”. The xpose.xtras pacakge also support labeling/units of the variable to make the plots more legible yet we still don’t know what ETA(1) refers to.\n\n\nCode\neta_vs_catcov(xpdb_x,etavar=ETA1, quiet=TRUE)\n\n\n\n\n\n\n\n\n\nA nice touch seen in the Eta versus categorical covriates plot is that out of the box we have the N by category shown on the x axis.\n\n\nCode\nxpdb_x$code$code[11:15]\n\n\n[1] \" TVCL = THETA(1)*(1+THETA(7)*(CLCR-65))\"\n[2] \" TVV = THETA(2)*WT\"                     \n[3] \" CL = TVCL*EXP(ETA(1))\"                 \n[4] \" V = TVV*EXP(ETA(2)) \"                  \n[5] \" KA = THETA(3)*EXP(ETA(3))\"             \n\n\nAccessing the database code we can see that ETA(1) is ETACL, ETA2 is ETAV and ETA3 is ETAKA. Since this is based on ggplot2 one can easily modify the generated plots. Here I use facet_grid to have one common y axis. I also put the shrinkage on the y axis title.\n\n\nCode\neta_vs_catcov(xpdb_x,etavar=c(ETA1), quiet=TRUE)+\nfacet_grid(~variable,scales=\"free_x\")+\nlabs(x=\"\",y=paste0(\"ηCL (\",get_shk(xpdb_x)[1],\"%)\"),\n       subtitle=\"Based on @nind individuals\")\n\n\n\n\n\n\n\n\n\nI still cannot generate one plot for multiple etas nor can I combine categorical and continuous covariates, let alone if I want to color by one important categorical covariate. let us try Certara.Xpose.NLME's eta_vs_cov This function plot all eta’s versus the specified categorical or continuous covariate.\n\n\nCode\netalables &lt;- c(\n  `ETA(1)` = paste0(\"ηCL\\n(\",get_shk(xpdb_x)[1],\"%)\"),\n  `ETA(2)` = paste0(\"ηV\\n(\",get_shk(xpdb_x)[2],\"%)\"),\n  `ETA(3)` = paste0(\"ηKa\\n(\",get_shk(xpdb_x)[3],\"%)\")\n)\n\neta_vs_cov(xpdb_x,covariate=c(\"SEX\"))+\n  facet_grid(variable~.,scales=\"free\",switch=\"y\",\n             labeller = labeller(variable=etalables))+\n  labs(x=\"\",y=\"\",\n   subtitle=\"Based on @nind individuals\")+\n  theme(strip.placement = \"outside\",\n        axis.title.x = element_blank(),\n        axis.title.y.left = element_blank(),\n        strip.text.y.left = element_text(angle=0))\n\n\n\n\n\n\n\n\n\nI still feel limited and not able to really look at everything as a whole. While I can try patchwork, I wanted to explore using ggduo which enables combining continuous and categorical covariates side by side. In this example, all categorical covariates have two levels. However, when the number of categories varies (e.g. Race with four categories) care should be taken on reserving space proportional to the number of the levels. To use ggduo we will use the raw table outputs and add a new categorical covariate combining MED1 and MED2 which will have levels: Both meds, MED2 only or none. ggduo allows the user to provide mapping = aes(color = SEX, fill = SEX) to color by any categorical covariate we want.\n\n\nCode\nxpdb_xdata &lt;- xpose::get_data(xpdb_x)\neta_shk &lt;- get_shk(xpdb_x, wh = \"eta\")\nnames(eta_shk) &lt;- c(\"ηCL\",\"ηVc\",\"ηKa\")\n\nxpdb_xdata &lt;- xpdb_xdata %&gt;% \n  select(ID,CL,V,KA,\n         ηCL  = ETA1, ηVc  = ETA2, ηKa = ETA3,\n         CLCR,AGE,WT,\n         SEX, MED1, MED2\n         ) %&gt;% \n  distinct(ID,.keep_all = TRUE)\n\n\nxpdb_xdata &lt;- xpdb_xdata %&gt;% \n  mutate(SEX = ifelse(SEX==\"1\",\"Male\",\"Female\"))%&gt;% \n  mutate(MED1 = ifelse(MED1==\"1\",\"Yes\",\"No\"))%&gt;% \n  mutate(MED2 = ifelse(MED2==\"1\",\"Yes\",\"No\"))%&gt;% \n  mutate(MED12 =  case_when(\n    MED1 == \"Yes\" & MED2 == \"Yes\" ~ \"Both\",\n    MED1 == \"Yes\" & MED2 == \"No\" ~ \"Digoxin\",\n    MED1 == \"No\" & MED2 == \"Yes\" ~ \"MED2\",\n    MED1 == \"No\" & MED2 == \"No\" ~ \"none\"\n  ))%&gt;%\n  dplyr::group_by(SEX) %&gt;%\n  dplyr::mutate(N_ID = dplyr::n() )%&gt;%\n  dplyr::mutate(SEXN = paste0(SEX,\"\\nN = \" ,N_ID) )%&gt;%\n  ungroup()%&gt;%\n  dplyr::group_by(MED1) %&gt;%\n  dplyr::mutate(N_ID = dplyr::n() )%&gt;%\n  dplyr::mutate(MED1N = paste0(MED1,\"\\nN = \" ,N_ID) )%&gt;%\n  ungroup()%&gt;%\n  dplyr::group_by(MED2) %&gt;%\n  dplyr::mutate(N_ID = dplyr::n() )%&gt;%\n  dplyr::mutate(MED2N = paste0(MED2,\"\\nN = \" ,N_ID) )%&gt;%\n  ungroup()%&gt;%\n  dplyr::group_by(MED12) %&gt;%\n  dplyr::mutate(N_ID = dplyr::n() )%&gt;%\n  dplyr::mutate(MED12N = paste0(MED12,\"\\nN = \" ,N_ID) )%&gt;%\n  ungroup()\n\nggduo(xpdb_xdata,\n      columnsX =c(\"AGE\", \"WT\",\"CLCR\", \"SEXN\",\"MED1N\",\"MED2N\",\"MED12N\") ,\n      columnsY = c(\"ηCL\", \"ηVc\", \"ηKa\"),\n      columnLabelsX =       c(\"Age\\n(years)\", \"Weight\\n(kg)\", \"CRCL\\n(ml/min)\", \n                              \"Sex\",\"Digoxin\",\"Med2\",\"Med1/2\"),\n      columnLabelsY = paste0(names(eta_shk),\"\\n\",eta_shk,\"%\"),\n      mapping = aes(color = SEX,fill = SEX),\n      xProportions = \"auto\",\n      types = list(\n        continuous = wrap(smooth_with_hline,\n                          method=\"loess\",se=FALSE,span=0.75,\n                          alpha=0.5,\n                          hlinecolor=\"blue\"\n                          ),\n        combo  = wrap(boxplot_with_hline,\n                      hlinecolor=\"blue\",outliers = FALSE)\n      ),\n      switch =\"both\"\n)+\n  theme_bw()+\n  theme(strip.placement = \"outside\",\n        strip.text.y.left = element_text(angle=0),\n        strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\",size = 10),\n        axis.text.x.bottom = element_text(size=rel(0.8)))+\n  labs(title = \"Eta versus covariates | run001\",\n       subtitle = \"Based on 74 individuals\",\n       caption =\"cov model: CL = CLpop×(1+θ×(CLCR-65)), V = Vpop×(Body Weight)\")+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.5)) \n\n\n\n\n\n\n\n\n\nThis is an improvement, where we can look at all ηs, all the covariates we want, and all the important info added. We can then wrap the code into a function to select a subset of the ηs and covariates.\n\n\nCode\neta_shk_model &lt;- get_shk(xpdb_x, wh = \"eta\")\nnames(eta_shk_model) &lt;- c(\"ηCL\",\"ηVc\",\"ηKa\")\n\ngof_etacovplot &lt;- function(dataset= xpdb_xdata,\n                           covariates = c(\"AGE\", \"WT\",\"CLCR\",\n                                          \"SEXN\",\"MED1N\",\"MED2N\",\"MED12N\") ,\n                           covlabels = c(\"Age\\n(years)\",\n                                         \"Weight\\n(kg)\", \"CRCL\\n(ml/min)\", \n                                         \"Sex\",\"Digoxin\",\"Med2\",\"Med1/2\"),\n                           etas = c(\"ηCL\",\"ηVc\",\"ηKa\"),\n                           eta_shk = eta_shk_model,\n                           smooth_method = \"loess\"){\n  ggduo(dataset, covariates,etas,\n        mapping = aes(color = SEX, fill = SEX),\n        columnLabelsX = covlabels,\n        columnLabelsY = paste0(names(eta_shk),\"\\n\",eta_shk,\"%\"),\n        xProportions = \"auto\",\n        types = list(\n          continuous = wrap(smooth_with_hline,\n                            hlinecolor=\"blue\",se=FALSE,col=\"gray40\",\n                            span = 0.9,\n                            alpha=0.5),\n          combo  = wrap(boxplot_with_hline,hlinecolor=\"blue\",outliers = FALSE)\n        ),\n        switch =\"both\"\n  )+\n    theme_bw()+\n    theme(strip.placement = \"outside\",\n          strip.text.y.left = element_text(angle=0),\n          strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n          strip.text = ggplot2::element_text(face = \"bold\", \n                                             color = \"white\"))+\n    labs(title = \"Eta versus covariates | run001\",\n         subtitle = \"Based on 74 individuals\",\n         caption =\"cov model: CL = CLpop×(1+θ×(CLCR-65)), V = Vpop×(Body Weight)\")+\n    scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n    scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.5)) \n  }\n\n\n\n\nCode\ngof_etacovplot(dataset= xpdb_xdata,\n               covariates = c(\"AGE\", \"WT\",\"SEXN\") ,\n               covlabels = c(\"Age\\n(years)\",\n                             \"Weight (kg)\", \"CRCL (ml/min)\"),\n               etas = c(\"ηCL\",\"ηVc\",\"ηKa\"))\n\n\n\n\n\n\n\n\n\n\n\nCode\ngof_etacovplot(dataset= xpdb_xdata,\n               covariates = c(\"MED1N\",\"MED2N\") ,\n               covlabels = c(\"Digoxin\",\"Med2\"),\n               etas = c(\"ηCL\",\"ηVc\",\"ηKa\"))\n\n\n\n\n\n\n\n\n\nIt is straightforward, for ggplot2 users to modify the underlying panel functions that are used by GGally::ggduo an example is shown below where I smooth_with_hline is based on ggally_smooth adding and ggplot2 code to add a horizontal line and control its color via the hlinecolor argument.\n\nsmooth_with_hline &lt;- function(data, mapping, method=\"loess\", hlinecolor=\"red\", ...) {\n  x &lt;- eval_data_col(data, mapping$x)\n  y &lt;- eval_data_col(data, mapping$y)\n  ggally_smooth(data, mapping,method = method, ...) +\n  geom_hline(color=hlinecolor,\n             data = data.frame(y = 0),\n             mapping = aes(yintercept = y),\n             inherit.aes = FALSE \n    )\n}\n# how it is used in GGally \n#wrap(smooth_with_hline,hlinecolor=\"blue\",se=FALSE,\n#     col=\"gray40\",span = 0.9,alpha=0.5)\n\nWhere are the p-values. I did not add p-values on purpose. Those wanting p-values can edit the function as they see fit. I don’t think it is appropriate to sprinkle p-values left and right and make decision on non-specified tests. As a bonus, I will leave you with a pairs plots using default ggpairs with p-values for the correlations.\n\n\nCode\n    ggpairs(xpdb_xdata,\n    mapping = aes(color = SEX, fill = SEX),\n          columns = c(\"WT\",\"AGE\",\"CLCR\",\"SEX\"),\n          columnLabels  = c(\"Weight\\n(kg)\",\"Age\\n(years)\", \"CRCL\\n(ml/min)\",\"SEX\"),\n  )+theme_bw()+\n    theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n          strip.text = ggplot2::element_text(face = \"bold\", \n                                             color = \"white\",size = 12))+\n    labs(title = \"Eta Correlations | run001\",\n         subtitle = \"Based on 74 individuals\",\n         caption =\"cov model: CL = CLpop×(1+θ×(CLCR-65)), V = Vpop×(Body Weight)\")+\n    scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n    scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.5)) \n\n\n\n\n\n\n\n\n\nAnd with custom functions highlighting the panel if it is significant:\n\n\nCode\n  ggpairs(xpdb_xdata,\n          columns = c(\"ηCL\",\"ηVc\",\"ηKa\"),\n          columnLabels  = paste0(names(eta_shk_model),\"\\n\",\n                                 eta_shk_model,\"%\"),\n          lower = list(continuous = my_custom_smooth),\n          upper = list(continuous = my_custom_cor_color),\n          diag =  list(continuous =my_custom_densityDiag),\n  )+\n    theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n          strip.text = ggplot2::element_text(face = \"bold\", \n                                             color = \"white\",size = 12))+\n    labs(title = \"Eta Correlations | run001\",\n         subtitle = \"Based on 74 individuals\",\n         caption =\"cov model: CL = CLpop×(1+θ×(CLCR-65)), V = Vpop×(Body Weight)\")\n\n\n\n\n\n\n\n\n\nFinally, in projects where we have lot of parameters, covariates, models we might wrap the plot generation into a loop that auto-generates tabs:\n\nηCLηVcηKa"
  },
  {
    "objectID": "posts/compareexposures/index.html",
    "href": "posts/compareexposures/index.html",
    "title": "Comparing Exposures with back to back Density/Boxplots",
    "section": "",
    "text": "In this post, I will cover visualizing simulated drug exposures head to head compare using some ggplot2 tricks. First we use the NHANES body weight (kg), illustrate the effects of taking into account survey weights in the quantile regression showing the 5th, 50th, and 95th percentiles. I also overlay the simulated demographics (red points).\n\n\nCode\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(nhanesgamlss)\nlibrary(gganimate)\n\nfactor.with.units &lt;- function(x, units) {\n  l &lt;- sort(unique(x))\n  y &lt;- factor(x, levels=l, labels=paste(l, units))\n}\n\n\n# note https://cran.r-project.org/web/packages/RNHANES/vignettes/introduction.html\n# RNHANES help in applying survey weights and in downloading NHANES data\n# I am using a bmxdata.csv\n# bmxdata &lt;- nhanes_load_data(\"BMX\", \"2013-2014\", cache = \"./nhanes_data\",\n#                              demographics = TRUE,recode = TRUE)\n\nbmxdata &lt;- read.csv(\"bmxdata.csv\")\npedcov4000 &lt;- read.csv(\"pedcov4000.csv\")  %&gt;% \n         filter(AGEY&lt;=18) %&gt;% \n      mutate(RIAGENDR = ifelse(SEX==\"boys\",\"Male\",\"Female\"))\nggplot(bmxdata %&gt;% \n         filter(RIDAGEYR&lt;=18),aes(RIDAGEYR,BMXWT))+\n  geom_point(aes(alpha=WTMEC2YR/1000) )+\n  geom_quantile(method = \"rqss\",quantiles = c(0.05,0.5,0.95),lambda= 10,\n  aes(weight = WTMEC2YR,col=\"rqss-weighted\"),linewidth=1.5, alpha = 0.6)+\n  geom_quantile(method = \"rqss\",quantiles = c(0.05,0.5,0.95),lambda= 10,\n  aes(col=\"rqss\"),linewidth=1.5, alpha = 0.6)+\n  geom_point(data = pedcov4000,aes(x=AGEY,y = WT),col=\"red\",alpha=0.1)+\n  facet_grid(~RIAGENDR)+\n  labs(x=\"Years\", y =\"Weight (kg)\",color=\"quantile regression\",\n       alpha=\"NHANES Weights\")+\n    scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n    theme_bw()+\n    theme(strip.placement = \"outside\",\n          strip.text.y.left = element_text(angle=0),\n          strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n          strip.text = ggplot2::element_text(face = \"bold\", \n                                             color = \"white\"))\n\n\n\n\n\n\n\n\n\nI then plug these demographics into an mrgsolve model and simulate flat fixed dose of 150 mg versus a 2 mg/kg dose ( 150 mg for a 75 kg individual). The resulting areas under the curves (AUC’s) are compared using boxplots.\n\n\nCode\nlibrary(mrgsolve)\n\ncodepedcov &lt;- '\n$PARAM\nKA=0.365, CL = 2, Vc=22,  Vp1 =200  ,Qp1= 4\nWT=75, AGE=18, SEX = 1\n$CMT GUT CENT PER1\n$MAIN\ndouble KAi = KA;\ndouble CLi = CL *pow((WT/75), 0.75)*exp(ETA(1));\ndouble Vci = Vc *pow((WT/75),    1)*exp(ETA(2));\ndouble Vp1i = Vp1 *pow((WT/75),    1);\ndouble Qp1i = Qp1 *pow((WT/75), 0.75);\ndouble Keli  = CLi/Vci    ;\ndouble Kpt1i =Vp1i/Vci    ;\ndouble Ktp1i =Qp1i/Vp1i   ;\n$OMEGA\n0.6\n$OMEGA\n0.6\n\n$ODE\ndxdt_GUT  = -KAi*GUT;\ndxdt_CENT =  KAi*GUT-Kpt1i*CENT-Keli*CENT+Ktp1i*PER1;\ndxdt_PER1 =          Kpt1i*CENT          -Ktp1i*PER1;\n\n$TABLE\ndouble CP    = CENT/ Vci;\ndouble CPER1 = PER1/Vp1i;\n$CAPTURE CP CPER1 CLi\n'\nmodcovpedsim &lt;- mcode(\"codepedcov\", codepedcov)\nidata &lt;- data_frame(ID=1:nrow(pedcov4000),\n                    WT=pedcov4000$WT,\n                    AGE=pedcov4000$AGEY,\n                    SEX=as.double(as.factor(pedcov4000$SEX )),\n                    TRT =1 \n)\nidata2 &lt;- data_frame(ID=1:nrow(pedcov4000),\n                     WT=pedcov4000$WT,\n                     AGE=pedcov4000$AGEY,\n                     SEX=as.double(as.factor(pedcov4000$SEX )),\n                     TRT =2 \n)\nidata &lt;- rbind(idata,idata2)\nrm(idata2)\nev1 &lt;- ev(time=0, amt=150, cmt=1)\ndata.dose &lt;- ev(ev1)\ndata.dose&lt;-as.data.frame(data.dose)\ndata.all&lt;-merge(idata,data.dose)\ndata.all$amt&lt;- ifelse( data.all$TRT==1,150,2*round(data.all$WT,0))\n\noutpedsim&lt;-modcovpedsim %&gt;%\n  data_set(data.all) %&gt;%\n  carry.out(TRT,WT,AGE,SEX,CLi) %&gt;%\n  mrgsim(end=24, delta=1)\noutpedsim&lt;-as.data.frame(outpedsim)\noutpedsim &lt;- outpedsim %&gt;% \n  arrange(ID,time,WT)\n\nout.ped.nca &lt;- outpedsim %&gt;% \n  group_by(ID,TRT,SEX,WT,AGE)%&gt;% \n  summarise (Cmax = max(CP,na.rm = TRUE),\n             Clast= CP[n()],\n             AUC= sum(diff(time ) *na.omit(lead(CP) + CP)) / 2,\n             CLi= median(CLi)) \n\nout.ped.nca$TRTC &lt;- ifelse(out.ped.nca$TRT==1,\"fixed Dose\",\"perkg Dose\")\nout.ped.nca$WTC &lt;- cut(out.ped.nca$WT,breaks = c(15,30,45,60,125))\nout.ped.nca$`Weight Category`  &lt;- factor.with.units(out.ped.nca$WTC, \"{kg}\")\n\nout.ped.nca$REGIMEN &lt;-  \"a.BASE\"\nggplot(out.ped.nca, aes(x=`Weight Category`, AUC))+\n  annotate(geom=\"rect\",xmin=-Inf,xmax=Inf,ymin=0.25,ymax=1.5,alpha=0.1,fill=\"blue\")+\n  geom_boxplot(aes(fill=TRTC,color = TRTC))+\n  facet_grid(REGIMEN~`Weight Category`,\n             labeller = labeller(`Weight Category`= label_value,\n                                 REGIMEN = label_value),scales=\"free\")+\n  theme_bw()+\n  theme(axis.text.x = element_blank(),legend.position=\"bottom\",\n        axis.ticks.x=element_blank(),\n        strip.text=element_text(size=12),\n        plot.title = element_text(size=14),\n        axis.text.y=element_text(size=12),axis.title.y = element_text(size=16))+\n  guides(color=guide_legend(reverse=TRUE),fill=guide_legend(reverse=TRUE))+\n  theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.5)) +\n  labs(y=\"Area Under the Curve (mg*h/mL)\",x=\"\")+\n  coord_trans(y = \"log\")+\n  guides(color=guide_legend(reverse=TRUE),\n         fill=guide_legend(reverse=TRUE))\n\n\n\n\n\n\n\n\n\nIdeally we want to keep what we compare close together i.e. the fixed Dose exposures next to the perKg Dose as shown in the second plot above. As a pharmacometrician, I like to see the distribution not just the boxplot so I come up with a hybrid density/boxplot visual below which I will call the back to back density boxplot.\n\n\nCode\nstatsdata &lt;- out.ped.nca %&gt;%\n  group_by(TRTC ,WTC,`Weight Category` ) %&gt;%\n  dplyr::summarize(\n    low=quantile(AUC, probs = c(0.05) ),\n    quart=quantile(AUC, probs = c(0.25) ),\n    med=quantile(AUC, probs = c(0.5) ),\n    seven=quantile(AUC, probs = c(0.75) ),\n    up=quantile(AUC, probs = c(0.95) )\n  )\n\nstatsdata$REGIMEN &lt;-\"a.BASE\"\n\nbacktobackhorizontal &lt;- ggplot(out.ped.nca, aes(x = AUC,fill=TRTC ,col=TRTC ),alpha=0.1) +\nfacet_grid(REGIMEN~`Weight Category`,\n           labeller = labeller(`Weight Category`= label_value,\n                               REGIMEN = label_value),scales=\"free_y\")+\n        annotate(geom=\"rect\",\n             ymin=-Inf,ymax=Inf,xmin=0.25,xmax=1.5,alpha=0.1,fill=\"blue\")+\n  stat_density(data=out.ped.nca[out.ped.nca$TRT ==1,],aes(ymax = 0.5*..scaled..,  ymin = rep(0)),\n               colour = \"transparent\",geom = \"ribbon\", position = \"identity\",alpha=0.1) +\n  stat_density(data=out.ped.nca[out.ped.nca$TRT ==2,],aes(ymin = -0.5*..scaled..,  ymax = rep(0)),\n               colour = \"transparent\",geom = \"ribbon\", position = \"identity\",alpha=0.1) +\n  geom_point(data=statsdata[statsdata$TRTC==\"perkg Dose\",]  , aes(x=med),y=-0.1)+\n  geom_point(data=statsdata[statsdata$TRTC!=\"perkg Dose\",]  , aes(x=med),y=0.1)+\n  geom_errorbarh(data=statsdata[statsdata$TRTC ==\"perkg Dose\",]  ,\n                 aes(x=med,y=-0.1,xmax = up, xmin = low),width = 0.1)+\n  geom_errorbarh(data=statsdata[statsdata$TRTC !=\"perkg Dose\",]  ,\n                 aes(x=med,y=0.1,xmax = up, xmin = low),width = 0.1)+\n  geom_errorbarh(data=statsdata[statsdata$TRTC ==\"perkg Dose\",]  ,\n                 aes(x=med,y=-0.1,xmax = seven, xmin = quart),width = 0.15)+\n  geom_errorbarh(data=statsdata[statsdata$TRTC !=\"perkg Dose\",]  ,\n                 aes(x=med,y=0.1,xmax = seven, xmin =quart),width = 0.15)+\n  labs(color=\"\",fill=\"\")\n\nbacktobackhorizontal+\n  coord_flip()+\n  labs(col=\"Dosing Type\",fill=\"Dosing Type\",\n       title=\"Comparing AUC Disributions:\\nFixed versus a Weight-Based Dosing Regimens\")+\n  scale_x_continuous(\"Area Under the Curve (mg*h/mL)\") +\n  ylab(\"\")+ \n  theme_bw()+\n  theme(axis.text.x = element_blank(),legend.position=\"bottom\",\n        axis.ticks.x=element_blank(),\n        strip.text=element_text(size=12),\n        plot.title = element_text(size=14),\n        axis.text.y=element_text(size=12),axis.title.y = element_text(size=16))+\n  guides(color=guide_legend(reverse=TRUE),fill=guide_legend(reverse=TRUE))+\n  theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.2)) \n\n\n\n\n\n\n\n\n\nWe see that the fixed dosing has the densities crossing above the therapeutic range [0.25-1.5] mg*h/mL.\nNext, we simulate two fixed dosing strategy reducing the fixed doses by a percentage:\n\nDose Strategy b: dose reduced by 80%, 50% and 40 % for the (45,60], (30,45], and (15,30] kg, respectively.\nDose Strategy c: dose reduced by 75%, 50% and 30 % for the (45,60], (30,45], and (15,30] kg, respectively.\n\nWe compare the outputs using boxplots:\n\n\nCode\n# simulate dose strategy 1 80 % 50 % 40 %\n\nev1 &lt;- ev(time=0,amt=150, cmt=1)\ndata.dose &lt;- ev(ev1)\ndata.dose&lt;-as.data.frame(data.dose)\ndata.all&lt;-merge(idata,data.dose)\ndata.all$amt&lt;- ifelse( data.all$TRT==1,150,2*round(data.all$WT,0))\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;60 ,150*0.8,data.all$amt)\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;45 ,150*0.5,data.all$amt)\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;30 ,150*0.4,data.all$amt)\n\noutpedsim&lt;-modcovpedsim %&gt;%\n  data_set(data.all) %&gt;%\n  carry.out(TRT,WT,AGE,SEX,CLi) %&gt;%\n  mrgsim(end=24, delta=1)\noutpedsim&lt;-as.data.frame(outpedsim)\noutpedsim &lt;- outpedsim %&gt;% \n  arrange(ID,time,WT)\n\nout.ped.nca.1 &lt;- outpedsim %&gt;% \n  group_by(ID,TRT,SEX,WT,AGE)%&gt;% \n  summarise (Cmax = max(CP,na.rm = TRUE),\n             Clast= CP[n()],\n             AUC= sum(diff(time ) *na.omit(lead(CP) + CP)) / 2,\n             CLi= median(CLi)) \nout.ped.nca.1$TRTC &lt;- ifelse(out.ped.nca.1$TRT==1,\"fixed Dose\",\"perkg Dose\")\nout.ped.nca.1$WTC &lt;- cut(out.ped.nca.1$WT,breaks = c(15,30,45,60,125))\nout.ped.nca.1$`Weight Category`  &lt;- factor.with.units(out.ped.nca.1$WTC, \"{kg}\")\n\n\n# simulate dose strategy 2 75 % 50 % 30 %\n\nev1 &lt;- ev(time=0,amt=150, cmt=1)\ndata.dose &lt;- ev(ev1)\ndata.dose&lt;-as.data.frame(data.dose)\ndata.all&lt;-merge(idata,data.dose)\ndata.all$amt&lt;- ifelse( data.all$TRT==1,150,2*round(data.all$WT,0))\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;60 ,150*0.75,data.all$amt)\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;45 ,150*0.5,data.all$amt)\ndata.all$amt&lt;- ifelse( data.all$TRT==1&data.all$WT&lt;30 ,150*0.30,data.all$amt)\n\n\noutpedsim&lt;-modcovpedsim %&gt;%\n  data_set(data.all) %&gt;%\n  carry.out(TRT,WT,AGE,SEX,CLi) %&gt;%\n  mrgsim(end=24, delta=1)\noutpedsim&lt;-as.data.frame(outpedsim)\noutpedsim &lt;- outpedsim %&gt;% \n  arrange(ID,time,WT)\n\nout.ped.nca.2 &lt;- outpedsim %&gt;% \n  group_by(ID,TRT,SEX,WT,AGE)%&gt;% \n  summarise (Cmax = max(CP,na.rm = TRUE),\n             Clast= CP[n()],\n             AUC= sum(diff(time ) *na.omit(lead(CP) + CP)) / 2,\n             CLi= median(CLi)) \nout.ped.nca.2$TRTC &lt;- ifelse(out.ped.nca.2$TRT==1,\"fixed Dose\",\"perkg Dose\")\nout.ped.nca.2$WTC &lt;- cut(out.ped.nca.2$WT,breaks = c(15,30,45,60,125))\nout.ped.nca.2$`Weight Category`  &lt;- factor.with.units(out.ped.nca.2$WTC, \"{kg}\")\n\nstatsdata1 &lt;- out.ped.nca.1 %&gt;%\n  group_by(TRTC ,WTC,`Weight Category` ) %&gt;%\n  dplyr::summarize(\n    low=quantile(AUC, probs = c(0.05) ),\n    quart=quantile(AUC, probs = c(0.25) ),\n    med=quantile(AUC, probs = c(0.5) ),\n    seven=quantile(AUC, probs = c(0.75) ),\n    up=quantile(AUC, probs = c(0.95) )\n  )\n\nstatsdata2 &lt;- out.ped.nca.2 %&gt;%\n  group_by(TRTC ,WTC,`Weight Category` ) %&gt;%\n  dplyr::summarize(\n    low=quantile(AUC, probs = c(0.05) ),\n    quart=quantile(AUC, probs = c(0.25) ),\n    med=quantile(AUC, probs = c(0.5) ),\n    seven=quantile(AUC, probs = c(0.75) ),\n    up=quantile(AUC, probs = c(0.95) )\n  )\nstatsdata1$REGIMEN &lt;-\"b.OPTIMIZED1\"\nstatsdata2$REGIMEN &lt;-\"c.OPTIMIZED2\"\nstatsdata1all &lt;-rbind(statsdata,statsdata1,statsdata2)\n\nout.ped.nca$REGIMEN &lt;-  \"a.BASE\"\nout.ped.nca.1$REGIMEN &lt;-\"b.OPTIMIZED1\"\nout.ped.nca.2$REGIMEN &lt;-\"c.OPTIMIZED2\"\n\nout.ped.nca$WTX &lt;- ifelse(out.ped.nca$`Weight Category`==\"(15,30] {kg}\",(15+30)/2,NA)\nout.ped.nca$WTX &lt;- ifelse(out.ped.nca$`Weight Category`==\"(30,45] {kg}\",(45+30)/2,out.ped.nca$WTX)\nout.ped.nca$WTX &lt;- ifelse(out.ped.nca$`Weight Category`==\"(45,60] {kg}\",(45+60)/2,out.ped.nca$WTX)\nout.ped.nca$WTX &lt;- ifelse(out.ped.nca$`Weight Category`==\"(60,125] {kg}\",(60+125)/2,out.ped.nca$WTX)\n\nout.ped.nca.2$WTX &lt;- ifelse(out.ped.nca.2$`Weight Category`==\"(15,30] {kg}\",(15+30)/2,NA)\nout.ped.nca.2$WTX &lt;- ifelse(out.ped.nca.2$`Weight Category`==\"(30,45] {kg}\",(45+30)/2,out.ped.nca.2$WTX)\nout.ped.nca.2$WTX &lt;- ifelse(out.ped.nca.2$`Weight Category`==\"(45,60] {kg}\",(45+60)/2,out.ped.nca.2$WTX)\nout.ped.nca.2$WTX &lt;- ifelse(out.ped.nca.2$`Weight Category`==\"(60,125] {kg}\",(60+125)/2,out.ped.nca.2$WTX)\nout.ped.nca.1$WTX &lt;- ifelse(out.ped.nca.1$`Weight Category`==\"(15,30] {kg}\",(15+30)/2,NA)\nout.ped.nca.1$WTX &lt;- ifelse(out.ped.nca.1$`Weight Category`==\"(30,45] {kg}\",(45+30)/2,out.ped.nca.1$WTX)\nout.ped.nca.1$WTX &lt;- ifelse(out.ped.nca.1$`Weight Category`==\"(45,60] {kg}\",(45+60)/2,out.ped.nca.1$WTX)\nout.ped.nca.1$WTX &lt;- ifelse(out.ped.nca.1$`Weight Category`==\"(60,125] {kg}\",(60+125)/2,out.ped.nca.1$WTX)\n\n\nout.ped.nca.all &lt;-rbind(out.ped.nca,out.ped.nca.1,out.ped.nca.2)\n\nggplot(out.ped.nca.all, aes(x=`Weight Category`, AUC))+\n  annotate(geom=\"rect\",xmin=-Inf,xmax=Inf,ymin=0.25,ymax=1.5,alpha=0.1,fill=\"blue\")+\n  geom_boxplot(aes(fill=TRTC,color = TRTC))+\n  facet_grid(REGIMEN~`Weight Category`,\n             labeller = labeller(`Weight Category`= label_value,\n                                 REGIMEN = label_value),scales=\"free\")+\n  theme_bw()+\n  theme(axis.text.x = element_blank(),legend.position=\"bottom\",\n        axis.ticks.x=element_blank(),\n        strip.text=element_text(size=12),\n        plot.title = element_text(size=14),\n        axis.text.y=element_text(size=12),axis.title.y = element_text(size=16))+\n  guides(color=guide_legend(reverse=TRUE),fill=guide_legend(reverse=TRUE))+\n  theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.5)) +\n  labs(y=\"Area Under the Curve (mg*h/mL)\",x=\"\")+\n  coord_trans(y = \"log\")+\n  guides(color=guide_legend(reverse=TRUE),\n         fill=guide_legend(reverse=TRUE))\n\n\n\n\n\n\n\n\n\nWe also re-do the back to back density boxplot comparing all three regimens:\n\n\nCode\nbacktobackhorizontalall &lt;- ggplot(out.ped.nca.all, aes(x = AUC,fill=TRTC ,col=TRTC ),alpha=0.1) +\n  annotate(geom=\"rect\",ymin=-Inf,ymax=Inf,xmin=0.25,xmax=1.5,alpha=0.1,fill=\"blue\")+\n  stat_density(data=out.ped.nca.all[out.ped.nca.all$TRT ==1,],aes(ymax = 0.5*..scaled..,  ymin = rep(0)),\n               colour = \"transparent\",geom = \"ribbon\", position = \"identity\",alpha=0.1) +\n  stat_density(data=out.ped.nca.all[out.ped.nca.all$TRT ==2,],aes(ymin = -0.5*..scaled..,  ymax = rep(0)),\n               colour = \"transparent\",geom = \"ribbon\", position = \"identity\",alpha=0.1) +\n  geom_point(data=statsdata1all[statsdata1all$TRTC==\"perkg Dose\",]  , aes(x=med),y=-0.1)+\n  geom_point(data=statsdata1all[statsdata1all$TRTC!=\"perkg Dose\",]  , aes(x=med),y=0.1)+\n  geom_errorbarh(data=statsdata1all[statsdata1all$TRTC ==\"perkg Dose\",]  ,\n                 aes(x=med,y=-0.1,xmax = up, xmin = low),width = 0.1)+\n  geom_errorbarh(data=statsdata1all[statsdata1all$TRTC !=\"perkg Dose\",]  ,\n                 aes(x=med,y=0.1,xmax = up, xmin = low),width = 0.1)+\n  geom_errorbarh(data=statsdata1all[statsdata1all$TRTC ==\"perkg Dose\",]  ,\n                 aes(x=med,y=-0.1,xmax = seven, xmin = quart),width = 0.15)+\n  geom_errorbarh(data=statsdata1all[statsdata1all$TRTC !=\"perkg Dose\",]  ,\n                 aes(x=med,y=0.1,xmax = seven, xmin =quart),width = 0.15)+\n  labs(color=\"\",fill=\"\",y=\"\")+\n  coord_flip()+\n  scale_x_continuous(\"Area Under the Curve (mU*h/mL)\") +\n  labs(col=\"Dosing Type\",fill=\"Dosing Type\",\n       title=\"Comparing AUC Disributions:\\nFixed versus a Weight-Based Dosing Regimens by Weight Category\")+\n  theme(axis.text.x = element_blank(),legend.position=\"bottom\", axis.ticks.x=element_blank(),\n        strip.text=element_text(size=12),\n        plot.title = element_text(size=14),\n        axis.text.y=element_text(size=12),axis.title.y = element_text(size=16))+\n  facet_grid(REGIMEN~`Weight Category`,labeller = labeller(`Weight Category`= label_value,\n                                                           REGIMEN = label_value\n                                                           ),scales=\"free_y\")+\n  guides(color=guide_legend(reverse=TRUE),\n         fill=guide_legend(reverse=TRUE))\nbacktobackhorizontalall+ \n  theme_bw()+\n  theme(axis.text.x = element_blank(),legend.position=\"bottom\",\n        axis.ticks.x=element_blank(),\n        strip.text=element_text(size=12),\n        plot.title = element_text(size=14),\n        axis.text.y=element_text(size=12),axis.title.y = element_text(size=16))+\n  guides(color=guide_legend(reverse=TRUE),fill=guide_legend(reverse=TRUE))+\n  theme(strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.2)) \n\n\n\n\n\n\n\n\n\nAs a bonus, I show how gganimate can be used to animate and transition the boxplots across regimens:\n\n\nCode\nlabeldata&lt;- rbind(\n  data.frame(TRTC = c(rep(\"fixed Dose\",4),rep(\"perkg Dose\",4)),\n             x=c((15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2,\n                 (15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2), \n             y = rep(Inf,8),\n             label= c(\"//\",\"//\",\"//\",\"   150 mg   \",\n                      \"//\",\"//\",\"//\",\"   2 mg/kg   \"),\n             REGIMEN = \"a.BASE\"),\n  data.frame(TRTC = c(rep(\"fixed Dose\",4),rep(\"perkg Dose\",4)),\n             x=c((15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2,\n                 (15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2), \n             y = rep(Inf,8),\n             label= c(\"x0.4\",\"x0.5\",\"x0.80\",\"   150 mg   \",\n                      \"//\",\"//\",\"//\",\"   2 mg/kg   \"),\n             REGIMEN = \"b.OPTIMIZED1\" ),\n  data.frame(TRTC = c(rep(\"fixed Dose\",4),rep(\"perkg Dose\",4)),\n             x=c((15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2,\n                 (15+30)/2,(45+30)/2,(45+60)/2,(60+125)/2), \n             y = rep(Inf,8),\n             label= c(\"x0.30\",\"x0.5\",\"x0.75\",\"   150 mg   \",\n                      \"//\",\"//\",\"//\",\"   2 mg/kg   \"),\n             REGIMEN = \"c.OPTIMIZED2\" )\n)\n\nggplot(out.ped.nca.all, aes(WT, AUC,col = TRTC, fill = TRTC))+\n  annotate(geom=\"rect\",xmin=-Inf,xmax=Inf,ymin=0.25,ymax=1.5,alpha=0.1,fill=\"blue\")+\n  geom_vline(data=data.frame(xintercept= c(15,30,45,60) ),\n             aes(xintercept=xintercept) )+\n  geom_boxplot(aes(x=WTX,group=WTX),alpha=0.5)+\n  geom_point(alpha=0.01,size=1)+\n  geom_label(data=labeldata,aes(x,y,label=label),vjust=\"inward\",fill=\"white\",\n             show.legend = FALSE)+\n  facet_grid(REGIMEN~TRTC,labeller=label_value)+\n  scale_x_continuous(breaks=c(15,30,45,60,125))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.2))+\n  labs(x=\"Weight (kg)\",y=\"Area Under the Curve (mg*h/mL)\")+\n  theme_bw()+\n  theme(strip.placement = \"outside\",\n        strip.text.y.left = element_text(angle=0),\n        strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\nInstead of facetting by regimen now we use transition_states(REGIMEN,...):\n\n\nCode\nggplot(out.ped.nca.all, aes(WT, AUC,col = TRTC, fill = TRTC))+\n  annotate(geom=\"rect\",xmin=-Inf,xmax=Inf,ymin=0.25,ymax=1.5,alpha=0.1,fill=\"blue\")+\n  geom_vline(data=data.frame(xintercept= c(15,30,45,60) ),aes(xintercept=xintercept) )+\n  geom_boxplot(aes(x=WTX,group=WTX),alpha=0.5)+\n  geom_point(alpha=0.01,size=1)+\n  geom_label(data=labeldata,aes(x,y,label=label),vjust=\"inward\",fill=\"white\")+\n  facet_grid(~TRTC,labeller=label_value)+\n  scale_x_continuous(breaks=c(15,30,45,60,125))+\n  scale_color_manual(values=c(\"#093B6D\", \"#EF761B\"))+\n  scale_fill_manual(values=alpha(c(\"#093B6D\", \"#EF761B\"),0.2))+\n  labs(x=\"Weight (kg)\",y=\"Area Under the Curve (mg*h/mL)\")+\n  theme_bw()+\n  theme(strip.placement = \"outside\",\n        strip.text.y.left = element_text(angle=0),\n        strip.background = ggplot2::element_rect(fill = \"#475c6b\"), \n        strip.text = ggplot2::element_text(face = \"bold\", \n                                           color = \"white\"))+\n  transition_states(\n    REGIMEN,\n    transition_length = 2,\n    state_length = 1\n  ) +\n  enter_fade() + \n  exit_shrink() +\n  ease_aes('sine-in-out')\n\n\n\n\n\n\n\n\n\nCode\n#anim_save(\"./boxplot.gif\",type=\"cairo-png\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Samer Mouksassi Blog Posts",
    "section": "",
    "text": "Comparing Exposures with back to back Density/Boxplots\n\n\n\npediatrics\n\nvisualization\n\n\n\n\n\n\n\n\n\nOct 16, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Covariate Plots\n\n\n\ncovariates\n\nvisualization\n\n\n\n\n\n\n\n\n\nOct 11, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nRandomization Tests\n\n\n\nstats\n\nsimulation\n\n\n\n\n\n\n\n\n\nOct 2, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Transitions over Time\n\n\n\nnews\n\nvisualization\n\n\n\n\n\n\n\n\n\nSep 19, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nDistributions of Exposures\n\n\n\nvisualization\n\ndistributions\n\n\n\n\n\n\n\n\n\nSep 1, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Time to Event Response\n\n\n\nnews\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 25, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Dose Exposure Response\n\n\n\nnews\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 18, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to Samer’s Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nAug 15, 2025\n\n\nSamer Mouksassi\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Samer MouksassiBio & Contact",
    "section": "",
    "text": "Hi, I have been working in the Model-Informed Drug Development field for more than 20 years. I have done projects for small start-ups, small, mid and large Pharmaceutical companies as well as Global Health key players like the Gates Foundation. My core services are focused on pharmacometrics analyses to support your drug development programs. I have contributed to 100+ projects, serving 40+ different clients ranging from pre-clinical, translational qsp and regulatory Population PK/PD filings using the totality of data including large phase III registration trials as well as real world data. Under my belt, I have contributed to 10+ regulatory approvals for FDA, EMA, PMDA, China and Health Canada across various therapeutic areas namely in rare diseases and pediatrics. Feel free to send me an email to start our discussion on how to start collaborating.\n\nTeachingExperienceEducationSelected Publications\n\n\nMy current and previous roles involved leading, mentoring and building pharmacometrics teams across the globe first with Pharsight in Montreal Canada and later with Certara in Cairo (Egypt) and Cape Town (South Africa). I have a passion for teaching and for building tools that empower non-coders to communicate efficiently. Some of my R packages include (coveffectsplot, ggquickeda and tidyvpc).\n\n\nFull Professional Researcher | Savic Lab\nUCSF, San Francisco | 2025 - Present\nSenior Director Pharmacometrics | Strategic Services Certara\nCairo/Cape Town | 2019 - 2024\nDirector Pharmacometrics | Strategic Services\nCertara, Montreal | 2014 - 2019\nAssociate Director Pharmacometrics | Consulting Services\nPharsight, Montreal | 2009 - 2014\nSenior Associate Scientist | Reporting and Analysis Services\nPharsight, Montreal | 2007 - 2009\n\n\nUniversity of Montreal, Montreal | Quebec, Canada\nPhD Pharmaceutical Sciences (Pharmacometrics) | 2006 - 2012\nUniversity of Montreal, Montreal | Quebec, Canada\nMSc Pharmaceutical Sciences (Pharmacometrics) | 2004 - 2006\nUniversity of Saint Joseph | Beirut Lebanon\nMSc Biostatistics and Epidemiology | 2002 - 2004\nLebanese University | Beirut, Lebanon\nPharm D | 1997 - 2003\n\n\n\nPharmacokinetic and pharmacodynamic modelling of continuous erythropoiesis receptor activator in children: A comprehensive analysis and real-world data validation. Samer Mouksassi, Franz Schaefer, Bradley A. Warady, Claus P. Schmitt, Sylvie Meyer Reigner, Milena Studer, Pascal Chanu, Nicolas Frey. Br J Clin Pharmacol. 2025;1–12. doi:10.1002/bcp.70165\nPharmacometric Analysis to Describe Pharmacokinetics and Exposure-Efficacy Response of Ivermectin in Adolescents Infected with Trichuris trichiura. Ajayi DT, Orherhe OM, Pillai GC, Mouksassi S, Steffens B, Bräm D, Sprecher V, Hofmann D, Buettcher M, Coulibaly JT, Ali SM, Keiser J, Pfister M. P. J Clin Pharmacol. 2024 Nov 6. doi: 10.1002/jcph.6158.\nPostmarketing Assessment of Antibody-Drug Conjugates: Proof-of-Concept Using Model-Based Meta-Analysis and a Clinical Utility Index Approach. Asiimwe IG, Chtiba N, Mouksassi S, Pillai GC, Peter RM, Yuen E, Pilla Reddy V. CPT Pharmacometrics Syst Pharmacol. 2025 Mar 4. doi: 10.1002/psp4.70013.\nAdvancing pharmacometrics in Africa-Transition from capacity development toward job creation. Pillai GC, Mouksassi S, Asiimwe IG, Rayner CR, Kern S, Sinxadi P, Denti P, Decloedt E, Waitt C, Ogutu BR, de Greef R. CPT Pharmacometrics Syst Pharmacol. 2025 Mar;14(3):407-419.\nQuantifying natural amyloid plaque accumulation in the continuum of Alzheimer’s disease using ADNI. Elhefnawy ME, Patson N, Mouksassi S, Pillai G, Shcherbinin S, Chigutsa E, Gueorguieva I. J Pharmacokinet Pharmacodyn. 2025 Jan 25;52(1):15.\nEEDBI Consortium.Anthropometry relationship with duodenal histologic features of children with environmental enteric dysfunction: a multicenter cross-sectional study. Jamil Z, VanBuskirk K, Mweetwa M, Mouksassi S, Smith G, Ahmed T, Chandwe K, Denno DM, Fahim SM, Kelly P, Mahfuz M, Mallawaarachchi I, Marie C, Moore SR, Petri WA Jr, Ali SA. Am J Clin Nutr. 2024 Sep;120 Suppl 1:S65-S72.\nMultiplexed immunohistochemical evaluation of small bowel inflammatory and epithelial parameters in environmental enteric dysfunction. VanBuskirk K, Mweetwa M, Kolterman T, Raghavan S, Ahmed T, Ali SA, Begum SKN, Besa E, Denno DM, Jamil Z,/&gt; Kelly P, Mahfuz M, Moore SR, Mouksassi S, Petri WA Jr, Tarr PI, Sullivan PB, Moskaluk CA; EEDBI Consortium. . Am J Clin Nutr. 2024 Sep;120 Suppl 1:S31-S40.\nHistopathology underlying environmental enteric dysfunction in a cohort study of undernourished children in Bangladesh, Pakistan, and Zambia compared with United States children. Kelly P, VanBuskirk K, Coomes D, Mouksassi S, Smith G, Jamil Z, Hossain MS, Syed S, Marie C, Tarr PI, Sullivan PB, Petri WA Jr, Denno DM, Ahmed T, Mahfuz M, Ali SA, Moore SR, Ndao IM, Tearney GJ, Ömer H Yilmaz, Raghavan SS, Moskaluk CA, Liu TC; EEDBI Consortium. Am J Clin Nutr. 2024 Sep;120 Suppl 1:S15-S30.\nUnderstanding Drug Exposure and Trichuris trichiura Cure rates: A Pharmacometric Approach for Albendazole‑Ivermectin Co‑medication in Tanzania and Côte d’Ivoire. Pillay‑Fuentes Lorente V, Nwogu‑Attah J, Steffens B, Bräm D, Sprecher V, Hofmann D, Buettcher M, Pillai G, Mouksassi S, Coulibaly J, Pfister M, Keiser J Drugs R D. 2024 Jun;24(2):331-340./&gt;\nMachine-Learning Assisted Screening of Correlated Covariates: Application to Clinical Data of Desipramine./&gt; Asiimwe IG, S’fiso Ndzamba B, Mouksassi S, Pillai GC, Lombard A, Lang J. AAPS J. 2024 May 30;26(4):63.\nTotality of evidence of the effectiveness of repurposed therapies for COVID-19: Can we use real-world studies alongside randomized controlled trials? Mandema J, Montgomery H, Dron L, Fu S, Russek-Cohen E, Bromley C, Mouksassi S, Lalonde A, Springford A, Tsai L, Ambery P, McNair D, Qizilbash N, Pocock S, Zariffa N. Clin Transl Sci. 2023 Oct;16(10):1842-1855.\n\n\n\n\nWhen not, analyzing data, building exciting data displays and innovating with new trial designs, I enjoy spending time in nature, working out and reading."
  },
  {
    "objectID": "posts/alluvialplots/index.html",
    "href": "posts/alluvialplots/index.html",
    "title": "Visualizing Transitions over Time",
    "section": "",
    "text": "In this post, I will cover visualizing longitudinal categorical data over time. I will start using a stacked barplot with percentages by category labels.\n\n\nCode\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(ggrepel)\nlibrary(ggh4x)\nlibrary(ggalluvial)\nlibrary(scales)\nlibrary(farver)\n\nexample&lt;- read.csv(\"example.csv\")\nexample$category &lt;- as.factor(example$category)\n\nggplot(example, aes(x = time,fill=category,color=category)) +\n  geom_bar(alpha = 0.8,\n           aes(y = ((..count..)/tapply(..count..,..PANEL.., sum)[..PANEL..])),\n           position = position_fill(vjust = 0.5),\n           col=\"transparent\")+\n  geom_text(\n           aes(y = ((..count..)/tapply(..count.., ..PANEL..,sum)[..PANEL..]),\n               label = paste0(..count..,\n                        \"%\"\n                        )),\n              stat = \"count\", vjust = 0.5, hjust = 0.5,\n              size = 4, position = position_fill(vjust = 0.5)  ,\n              show.legend = FALSE,col=\"black\") +\n  scale_y_continuous(expand = expansion(mult=c(0,0),add = c(0,0)),\n                     labels = scales::percent_format(accuracy=1))+\n  scale_x_discrete(  expand = expansion(mult=c(0,0),add = c(0,0))) +\n  theme_bw(base_size =18)+\n  theme(panel.border = element_blank())+\n  labs(y=\"Percentage of Categories\",x=\"Time\")+\n  scale_y_discrete() +\n  theme(axis.text = element_text(size = 12))+\n  scale_fill_manual(\n    values=rev(c(\n      \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n  scale_color_manual(\n    values=rev(c(\n      \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n  scale_y_continuous(expand = expansion(mult=c(0,0),add = c(0,0)))+\n  scale_x_discrete(  expand = expansion(mult=c(0,0),add = c(0,0))) +\n  theme_bw(base_size =18)+\n  theme(panel.border = element_blank())\n\n\n\n\n\n\n\n\n\nIt is often of interest to understand and visualize how individuals transition between categories over time. As such, we will augment the barplots by including flows using alluvial plots. Another small tweak is to let the percentage label color change depending on the contrasting background via farver::decode_colour. The `flows’ are colored by the starting category.\n\n\nCode\nggplot(example, \n       aes(alluvium = ID, x = time , stratum = category)) + \n  geom_stratum( aes(fill=category,y=after_stat(prop)),decreasing = NA,alpha=0.8)  + \n  geom_flow(aes(fill=category),aes.flow = \"forward\",alpha = 0.8) +\n  geom_text_repel(stat = \"stratum\",\n                   aes(color = stage(category, after_scale = ifelse(\n                     decode_colour(alpha(color, 0.8),\"rgb\", \"hcl\")[, \"l\"] &gt; 50,\n                     \"black\",\"white\")\n                   ),\n                   label = percent(after_stat(prop), accuracy = 1)),\n                   show.legend = FALSE,direction=\"y\")+\n  scale_y_discrete() +\n  theme_bw(base_size =18)+\n  theme(axis.text = element_text(size = 12))+\n  scale_fill_manual(\n    values=rev(c(\n      \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n  scale_color_manual(\n  values=rev(c(\n    \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n  scale_y_continuous(expand = expansion(mult=c(0,0),add = c(0,0)))+\n  scale_x_discrete(  expand = expansion(mult=c(0,0),add = c(0,0))) +\n  theme_bw(base_size =18)+\n  theme(panel.border = element_blank())+\n  labs(y=\"Percentage of Categories\",x=\"Time\")\n\n\n\n\n\n\n\n\n\nThe previous plot showed the percentages in each category overall. Next we show the percentage undergoing each transition, coloring the flows the ending category.\n\n\nCode\nggplot(example , \n       aes(alluvium = ID, x = time, stratum = category)) + \n  geom_stratum( aes(fill=category,y=after_stat(prop)),alpha=0.8)  + \n  geom_flow(aes(fill=category),aes.flow = \"backward\" ,alpha=0.8) +\n  geom_text_repel(stat = \"flow\",\n                  aes(\n                    color = stage(category, after_scale = ifelse(\n                      decode_colour(alpha(color, 0.8),\"rgb\", \"hcl\")[, \"l\"] &gt; 50,\n                      \"black\",\"white\")\n                    ),\n                  label = after_stat(\n                    scales::percent(\n                      ave(count, x, flow,PANEL, group, FUN = sum) /\n                        ave(count, x, flow,PANEL, FUN = sum),accuracy = 1) ),\n                                      hjust = after_stat(flow) == \"to\" \n  ),direction=\"y\",show.legend = FALSE)+\n    scale_y_discrete() +\n    theme_bw(base_size =18)+\n    theme(axis.text = element_text(size = 12))+\n    scale_fill_manual(\n      values=rev(c(\n        \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n    scale_color_manual(\n      values=rev(c(\n        \"gray\",\"#2171B5\",\"#4292C6\", \"#9ECAE1\",\"#C6DBEF\")))+\n    scale_y_continuous(expand = expansion(mult=c(0,0),add = c(0,0)))+\n    scale_x_discrete(  expand = expansion(mult=c(0,0),add = c(0,0))) +\n    theme_bw(base_size =18)+\n    theme(panel.border = element_blank())+\n    labs(y=\"Percentage of Categories\",x=\"Time\")\n\n\n\n\n\n\n\n\n\nNext, I try something different. I reshape the data and plot the current category to where it ended next by time point. The text show the numbers and direction of transition. At the first time point t1 there is no transition all data are on the diagonal. At time t2, the 31 data points that were at category 3 are now split into:\n\n4 at category 3,\n23 at category 4\nand 4 at category 5.\n\n\n\nCode\nexample.trans&lt;- example %&gt;% \n  group_by(ID) %&gt;% \n  mutate(category= as.double(category))%&gt;% \n  mutate(prevcategory=lag(category))%&gt;% \n  ungroup()\nexample.trans &lt;- example.trans %&gt;% \n  group_by(time,category, prevcategory) %&gt;%  \n  summarise(N=n()) %&gt;% \n  ungroup()\nexample.trans &lt;- example.trans %&gt;% \n  mutate(prevDV=ifelse(time==0,category,prevcategory))%&gt;% \n  complete(time = c(\"t1\" ,\"t2\", \"t3\" ,\"t4\", \"t5\" ,\"t6\"),\n           prevcategory=  1:6,\n           category=      1:6,\n           fill=list(N=0))\n\n\nexample.trans %&gt;% \n  mutate(prevcategory=ifelse(time==\"t1\",category,prevcategory))%&gt;% \n  mutate( transsign= ifelse(category-prevcategory&gt;0,\"increase\",\n                     ifelse(category-prevcategory==0,\"no change\",\"decrease\"))\n  )%&gt;% \n  filter(!is.na(prevcategory),N!=0)%&gt;% \n  mutate(transsign= factor(transsign,levels = c(\"decrease\",\"no change\",\"increase\")))%&gt;% \n  ggplot(.,aes(category,prevcategory,label=N))+\n  geom_abline(color=\"gray\")+\n  geom_text(alpha=1,aes(colour=transsign, size=N),\n            show.legend = c( colour = TRUE,size = FALSE) \n            )+\n  facet_wrap( ~ time,\n               labeller = labeller(time= label_both),ncol=3,\n               dir=\"lt\" )+\n  scale_x_continuous(breaks=c(1,2,3,4,5,6,7))+\n  scale_y_continuous(breaks=c(1,2,3,4,5,6,7))+\n  theme_bw(base_size = 22)+\n  theme(strip.placement = \"outside\",strip.text.y.left = element_text(angle=0),\n        legend.position = \"right\",\n        aspect.ratio = 1,\n        strip.background = element_rect(fill = \"#475c6b90\"), \n        strip.text = element_text(face = \"bold\",color = \"white\"))+\n  labs(y=\"previous category\",x=\"category\",size=\"N\\nTransitions\",\n       color=\"Transitions\\nDirection\")+\n  scale_size(range=c(4,10))+\n  coord_cartesian(clip=\"off\")+ \n  guides(colour = guide_stringlegend(ncol = 1))+\n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\n\nWith this post, I covered some techniques that can be useful to visualize longitudinal categorical data and set the stage for advanced modeling techniques such as multi-state markovian models."
  },
  {
    "objectID": "posts/erplots/index.html",
    "href": "posts/erplots/index.html",
    "title": "Visualizing Dose Exposure Response",
    "section": "",
    "text": "In this post I will provide the code and thinking process behind the figure shared in my first blog post. We will start with a simpler version where we show the Endpoint versus exposures, which in this case are areas under the drug concentrations curves (AUC) on top. And at the bottom, the individual AUCs by dose level with a different symbol by responder status: responder (as triangles) and not responder (as circles).\n\n\nCode\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggquickeda)\nlibrary(patchwork)\nlibrary(ggridges)\nlibrary(ggrepel)\n\nICGI&lt;- read.csv(\"ICGI.csv\")\nICGI$responder &lt;- ifelse(ICGI$ICGI==1,\"responder\",\n                         \"not responder\")\nICGI$DOSE &lt;- as.factor(ICGI$DOSE)\nICGI$DOSE &lt;- factor(ICGI$DOSE,\n                    levels=c(\"0\", \"600\", \"1200\",\"1800\",\"2400\"),\n                    labels=c(\"Placebo\", \"600 mg\", \"1200 mg\",\"1800 mg\",\"2400 mg\"))\np1 &lt;-  ggplot(ICGI, aes(AUC, ICGI)) +\n  geom_point(\n    aes(shape=responder),\n    position = position_jitter(height = 0.08),\n    size = 3,\n    alpha = 0.2\n  ) +\n  geom_smooth(\n    method = \"glm\",\n    method.args = list(family = \"binomial\"),\n    se = TRUE\n  ) +\n  theme_bw(base_size = 16) +\n  guides(shape=guide_legend(reverse=TRUE))+\n  labs(x=\"AUC (µg*h/mL)\",y=\"Probability of Endpoint\", shape = \"\")\n\np2 &lt;-\n  ggplot(ICGI, aes(AUC, DOSE)) +\n  geom_point(\n    data = ICGI[ICGI$responder == \"responder\", ],\n    position = position_nudge(y = -0.25),\n    size = 3,\n    alpha = 0.2,\n    shape = \"circle\"\n  ) +\n  geom_point(\n    data = ICGI[ICGI$responder != \"responder\", ],\n    position = position_nudge(y = 0.25),\n    size = 3,\n    alpha = 0.2,\n    shape = \"triangle\"\n  ) +\n  theme_bw(base_size = 16) +\n  labs(y = \"Dose\")\n(p1+\ntheme(legend.position = \"inside\",\n      legend.position.inside = c(0.8,0.55),\n      legend.background = element_rect(fill = \"transparent\",\n                                       colour = \"black\"),\n      legend.title = element_blank(),\n  axis.text.x.bottom = element_blank(),\n      axis.title.x.bottom = element_blank())+\n  scale_y_continuous(breaks= seq(0,1,0.2),\n                     labels = scales::percent_format())\n  )/(p2+\n  scale_x_continuous(breaks= seq(0,400,50))+\n  labs(x=\"AUC (µg*h/mL)\",shape =\"\"))\n\n\n\n\n\n\n\n\n\nWith this visual representation several questions remain without an answer:\n\nWhat is the probability of response by dose level?\nWhat is the probability of response by tertiles or quartiles of exposures ? and how about the Placebo (exposure = 0) response?\n\nWe will answer these questions incrementally. First we reshape the data into long format to accomodate the possibility of multiple endpoints and multiple exposure metrics. Second we compute the quartiles of exposures by exposure metric and endpoint, keeping the Placebo separate. Then we add the variable exptile that will assign to each exposure one of the following values: “Placebo”, “Q1”, “Q2”, “Q3”, “Q4”. We also compute the exposure limits that can be used in the graph to show the limits of each quartile.\n\n\nCode\nexposure_metric_plac_value &lt;- 0\n# compute quantiles and assign each exposure to its corresponding exptile\nICGIlong &lt;- ICGI %&gt;% \n  gather(Endpoint,response,ICGI)    %&gt;% # can handle multiple endpoints at the same time \n  gather(expname,expvalue,AUC,CMAX) %&gt;% # can handle multiple exposures at the same time\n  group_by(Endpoint,expname) %&gt;% \n  mutate( Q25     = quantile(expvalue[!expvalue %in% c(exposure_metric_plac_value)], 0.25, na.rm = TRUE), \n          Q50     = quantile(expvalue[!expvalue %in% c(exposure_metric_plac_value)], 0.50, na.rm = TRUE), \n          Q75     = quantile(expvalue[!expvalue %in% c(exposure_metric_plac_value)], 0.75, na.rm = TRUE), \n          exptile = case_when(expvalue == exposure_metric_plac_value ~ \"Placebo\",\n                            expvalue &gt; exposure_metric_plac_value & expvalue &lt;= Q25\n                                                               ~ \"Q1\",\n                            expvalue &gt;  Q25 & expvalue &lt;=  Q50 ~ \"Q2\",\n                            expvalue &gt;  Q50 & expvalue &lt;= Q75  ~ \"Q3\",\n                            expvalue &gt;  Q75                    ~ \"Q4\"))\n\nexposurelimits &lt;- ICGIlong %&gt;% \n  group_by(expname, Endpoint)%&gt;% \n  reframe(intercept = quantile(expvalue[!expvalue %in%\n                         c( exposure_metric_plac_value)], \n                         c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE),\n              quant =    c(0,0.25, 0.5, 0.75, 1))\n\n\nWe prepare the distributions plot beneath the probability of response curve by using ggridges, constructing a numrical value for where to plot the distributions and by excluding the Placebo from the distributions plot. The distributions are shown as densities scaled to 1 with quantiles lines at 10th, 25th 50th, 75th and 90th percentiles.\n\n\nCode\n#these values will become an argument in the ER function\n  dist_position_scaler = 0.2\n  dist_offset = 0\n  dist_scale = 0.9\nICGIlong$keynumeric &lt;- -dist_position_scaler * as.numeric(\n    forcats::fct_rev(as.factor(dplyr::pull(ICGIlong[,\"DOSE\"])))) + dist_offset\n  \np1 &lt;- ggplot(ICGIlong, aes(expvalue,response) )+\n  geom_point(aes(col=DOSE))+\n  geom_hline(yintercept=c(0,1),col=\"darkgray\")+\n  geom_vline(data=exposurelimits,aes(xintercept = intercept),col=\"lightgray\",\n             linetype=\"dashed\")+\n   geom_text(data=exposurelimits,\n             aes(x = intercept,y=Inf,label=round(intercept,1)),col=\"lightgray\",\n             vjust=1)+\n  geom_smooth(method=\"glm\",\n              method.args = list(family = \"binomial\"),\n              color=\"black\",aes(fill=\"logistic fit (95%CI)\"))+\n  geom_density_ridges(data=ICGIlong %&gt;% \n                        filter(DOSE!=\"Placebo\"),\n                      aes(expvalue,y=keynumeric,\n                          group=DOSE,col=DOSE,\n                          height = after_stat(ndensity)),\n                      rel_min_height = 0.005,alpha=0.1,scale = dist_scale,\n                      quantile_lines = TRUE, quantiles = c(0.1,0.25, 0.5, 0.75,0.9))+\n   geom_point(data=ICGIlong%&gt;% \n                        filter(DOSE!=\"Placebo\"), aes(expvalue,y=keynumeric-0.025,col=DOSE),alpha = 0.2)+\n  facet_grid(~expname,scales=\"free_x\")+\n  ggthemes::scale_color_tableau()+\n  scale_fill_manual(values=\"gray\")+\n  labs(fill=\"\")+\n  theme_bw()+\n  theme(legend.position = \"top\")+\n  guides(fill  = guide_legend(order = 1),\n         color = guide_legend(order = 2, nrow=2, reverse = TRUE))\n\n\nNext we compute the probabilities of response by exposures quartiles and by dose levels and add it to the plot using geom_pointrange\n\n\nCode\nsummary_df &lt;- function (x, y, probs = c(0.1, 0.25, 0.75, 0.9), continuous = FALSE) \n{\n    tibble::tibble(minexp = min(x),\n                   maxexp = max(x),\n                   medexp = median(x), \n        meanexp = mean(x),\n        N = ifelse(!continuous, sum(y, na.rm = TRUE), \n            n()),\n        Nmiss = length(x[is.na(x)]),\n        Ntot = dplyr::n(), \n        meanresp = ifelse(!continuous, N/Ntot, mean(y, na.rm = TRUE)), \n        prob = meanresp,\n        SE = ifelse(!continuous,\n            sqrt(meanresp * (1 - meanresp)/Ntot),\n            sd(y, na.rm = TRUE)/sqrt(Ntot)), \n        values = quantile(x, probs, na.rm = TRUE), quant = probs)\n}\n\nICGIlong.summaries.dose &lt;- ICGIlong %&gt;% \n    group_by(Endpoint,expname,DOSE,keynumeric) %&gt;% \n    reframe(summary_df(expvalue,response))%&gt;% \n  pivot_wider(names_from = quant, \n  values_from = values, names_glue = \"quant_{100*quant}\")\n  \n  ICGIlong.summaries.exposure &lt;- ICGIlong %&gt;% \n    ungroup() %&gt;% \n    group_by(Endpoint,expname,exptile) %&gt;% \n    reframe(summary_df(expvalue,response))%&gt;% \n  pivot_wider(names_from = quant, \n  values_from = values, names_glue = \"quant_{100*quant}\")\n  \n\np2 &lt;- p1 +\n   geom_linerange(data=ICGIlong.summaries.dose,\n                  aes(x=medexp,xmin = quant_10,xmax = quant_90,\n                      y=keynumeric+0.025,col=DOSE),\n                  linewidth = 2, alpha = 0.4)+\n   geom_linerange(data=ICGIlong.summaries.dose,\n                  aes(x=medexp,xmin = quant_25,xmax = quant_75,\n                      y=keynumeric+0.025,col=DOSE),\n                  linewidth = 2.5, alpha = 0.4)+\n   geom_point(data=ICGIlong.summaries.dose,\n                  aes(x=medexp,\n                      y=keynumeric+0.025,col=DOSE),\n                  size = 3, alpha = 0.2)+\n  geom_pointrange(data=ICGIlong.summaries.dose,\n                  alpha=0.4,\n                  aes(x= medexp, y = meanresp,\n                      ymin =meanresp-1.96*SE,\n                      ymax =meanresp+1.96*SE,\n                      col = DOSE,\n                      shape =\"by dose\")\n                  )+\n  geom_pointrange(data=ICGIlong.summaries.exposure,\n                  alpha=0.4,\n                  aes(x= medexp, y = meanresp,\n                      ymin =meanresp-1.96*SE,\n                      ymax =meanresp+1.96*SE,\n                      shape =\"by quartile\")\n                  )+\n  labs(shape=\"observed\\nprobability\")+\n  guides(shape = guide_legend(order=3,nrow=2,reverse = TRUE))\n\n\nFinally we want to annotate the plot by displaying for each exptile the bin limits, the total N of subjects, the N of responders the probability of response.\n\n\nCode\nICGIlong.summaries.exposure &lt;- ICGIlong.summaries.exposure %&gt;% \n  mutate(label= ifelse(exptile!=\"Placebo\",\n                       paste0(exptile,\"\\n\",\"[\",round(minexp,0),\"-\",round(maxexp,0),\"]\",\n                             \"\\n\",N,\"\\n\",Ntot,\"\\n\",\n                              round(100*meanresp,1)),\n                       paste0(exptile,\"\\n\",\"\",\n                             \"\\n\",N,\"\\n\",Ntot,\"\\n\",\n                              round(100*meanresp,1))\n                       \n                       ),\n         \n         \n         ytext= 0.25)\np2txt &lt;- p2 +\n  geom_text(data=ICGIlong.summaries.exposure,size = 1.5,\n            aes(x=meanexp ,label=label,y=ytext),inherit.aes = FALSE)+\n  facet_wrap(~expname,ncol=2,scales = \"free_x\")\n  \np2txt +\n  scale_y_continuous( \nbreaks = c(sort(unique(ICGIlong$keynumeric)), \nc(0, 0.25,  0.5,0.75, 1)),\nlabels = c(levels(ICGIlong$DOSE), \nc(\"0\", \"25%\", \"50%\",\"75%\",\"100%\")),\n             expand = expansion(mult = c(0.01, 0.01), \n                                add = c(0, 0))\n\n)+\nlabs(x=\"Exposure Values\",\n     y=\"Probability of Endpoint\")\n\n\n\n\n\n\n\n\n\nIn the ggquickeda package the ggresponseexpdist function automate a lot of these operations to be able to generate these advanced plots using concise syntax.\n\n\nCode\nICGIERDATA &lt;- ICGI\nICGIERDATA$Endpoint &lt;- \"ICGI\"\nICGIERDATA$response &lt;- ICGIERDATA$ICGI \n\nggresponseexpdist(data = ICGIERDATA,\nmodel_type = \"logistic\",\nexposure_metrics = c(\"AUC\"),\nexposure_metric_split = \"quartile\",\nN_byexptile_ypos = \"with means\",\nmean_obs_bydose = TRUE,\nmean_obs_bydose_plac = FALSE,\nN_bydose_ypos = \"none\",\nmean_obs_bydose_text_size = 0,\nN_text_size = 3,\nexposure_distribution_percent = \"%\")"
  },
  {
    "objectID": "posts/exposuredistributions/index.html",
    "href": "posts/exposuredistributions/index.html",
    "title": "Distributions of Exposures",
    "section": "",
    "text": "In this post, I will cover visualizing the exposure distributions with more details. The blog post that covered binary response outcomes showed how we often show the distributions of exposures by dose level or study arm, and what interesting summaries we might want to add to it. Keep in mind that we give a dose to a patient and we don’t fully control the resulting exposure. That is because, even when we use the same dose level, different patients would achieve different exposures given that they have different body weights, different metabolism and different physiological characteristics. In today’s post, I will reuse the same binary logistic data and incrementally add info to this plot, each time giving the rationale behind what we are trying to do. First, we compute the quartiles of exposure across all dose levels (without Placebo) and show distribution densities using ggplot2 geom_density, split/facet by Dose colored by Dose and then colored by quartiles. (This feature is supported in ggplot2 &gt; 4.0).\n\n\nCode\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggquickeda)\nlibrary(patchwork)\nlibrary(ggridges)\nlibrary(ggrepel)\nlibrary(ggdist)\n\nICGI&lt;- read.csv(\"ICGI.csv\")\nICGI$responder &lt;- ifelse(ICGI$ICGI==1,\"responder\",\n                         \"not responder\")\nICGI$DOSE &lt;- as.factor(ICGI$DOSE)\nICGI$DOSE &lt;- factor(ICGI$DOSE,\n                    levels=c(\"0\", \"600\", \"1200\",\"1800\",\"2400\"),\n                    labels=c(\"Placebo\", \"600 mg\", \"1200 mg\",\"1800 mg\",\"2400 mg\"))\n\nAUCquantiles &lt;-   quantile(ICGI$AUC[ICGI$AUC&gt;0],\n                           probs = c(0.25,0.5,0.75))\nq25 &lt;- AUCquantiles[1]\nq50 &lt;- AUCquantiles[2]\nq75 &lt;- AUCquantiles[3]\n\nICGI &lt;- ICGI %&gt;% \n  mutate(AUC_Q = case_when(AUC ==0            ~ \"Placebo\",\n                          AUC &lt;= q25             ~ \"Q1\",\n                          AUC &gt; q25 & AUC &lt;= q50 ~ \"Q2\",\n                          AUC &gt; q50 & AUC &lt;= q75 ~ \"Q3\",\n                          AUC &gt; q75              ~ \"Q4\"))\n\n\nggplot(ICGI ,\n       aes(x= AUC))+\n  geom_density(aes(y=after_stat(scaled), fill = DOSE),alpha=0.2)+\n  geom_rug()+\n  geom_vline(xintercept = AUCquantiles)+\n  facet_grid(DOSE~.,as.table = FALSE,switch=\"y\")+\n  scale_fill_manual(values=c(\"#4682AC\", \n            \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  scale_color_manual(values=c(\"#4682AC\", \n            \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  theme_bw()+\n  theme(strip.background = element_rect(fill = \"#475c6b\"),\n        strip.text.y.left =   element_text(face = \"bold\",\n                                           color = \"white\",angle=0),\n        strip.placement = \"outside\", axis.title.y.left = element_blank())\n\n\n\n\n\n\n\n\n\nCode\nggplot(ICGI %&gt;% \n         filter(DOSE!=\"Placebo\"))+\n  geom_rug(aes(x = AUC,color = AUC_Q ) ,length = unit(0.2,\"cm\"))+\n  geom_density(aes(x = AUC,\n                   group = DOSE,\n                   y=after_stat(scaled),\n                   fill = after_stat(\n                     case_when(x &lt;= q25 ~ \"Q1\",\n                               x &gt; q25 & x &lt;= q50 ~ \"Q2\",\n                               x &gt; q50 & x &lt;= q75 ~ \"Q3\",\n                               x &gt; q75 ~ \"Q4\"))),alpha=0.5)+\n  geom_vline(xintercept = c(q25,q50,q75))+\n  labs(fill=\"Quartiles\",color=\"Quartiles\")+\n  facet_grid(DOSE~.,as.table = FALSE,switch=\"y\")+\n  scale_fill_manual(values=c(\"#4682AC\", \n            \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  scale_color_manual(values=c(\"#4682AC\", \n            \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  theme_bw()+\n  theme(strip.background = element_rect(fill = \"#475c6b\"),\n        strip.text.y.left =   element_text(face = \"bold\",\n                                           color = \"white\",angle=0),\n        strip.placement = \"outside\", axis.title.y.left = element_blank())\n\n\n\n\n\n\n\n\n\nNext, I use ggridges where we put each dose at the y axis and add a “pooled” distribution across all doses (without Placebo). Then I also show the quartiles lines (25%, 50% and 75%) for each dose level and pooled. All values for Placebo are naturally zero and as such I omit the distribution for Placebo. The computed quartiles (which were computed earlier) matches those automatically computed by ggridges.\n\n\nCode\nggplot(rbind(ICGI %&gt;% \n               filter(AUC&gt;0),\n             ICGI %&gt;%\n               mutate(DOSE= \"(pooled)\") %&gt;% \n               filter(AUC&gt;0)),\n              aes(x = AUC, y = DOSE, fill = DOSE)) +\n  geom_density_ridges(rel_min_height = 0.01,\n                      quantile_lines = TRUE,\n                      jittered_points = TRUE,\n                      position = \"raincloud\",\n                      alpha = 0.4,\n                      scale = 1)+\n  geom_vline(xintercept = AUCquantiles)+\n  guides(fill = guide_legend(reverse = TRUE))+\n  scale_x_continuous(breaks= seq(0,400,50))+\n  theme_bw()+\n  labs(x=\"AUC (µg*h/mL)\",shape =\"\")+\n  scale_fill_manual(values=c(\"#4682AC\", \n            \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))\n\n\n\n\n\n\n\n\n\nWhat we want to reason about is how many patients would achieve exposures within quartiles limits at a given dose level ? This would tell us about the probability of achieving exposures below the first quartile (Q1), between Q1 and Q2, between Q2 and Q3 and ≥ Q4. We compute the quantities of interest using table1 as well as using simple counting by Dose and quartile category.\n\n\nCode\ntable1::table1(~AUC_Q|DOSE,ICGI,overall = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlacebo\n(N=244)\n600 mg\n(N=149)\n1200 mg\n(N=238)\n1800 mg\n(N=36)\n2400 mg\n(N=37)\n\n\n\n\nAUC_Q\n\n\n\n\n\n\n\nPlacebo\n244 (100%)\n0 (0%)\n0 (0%)\n0 (0%)\n0 (0%)\n\n\nQ1\n0 (0%)\n103 (69.1%)\n12 (5.0%)\n0 (0%)\n0 (0%)\n\n\nQ2\n0 (0%)\n46 (30.9%)\n67 (28.2%)\n2 (5.6%)\n0 (0%)\n\n\nQ3\n0 (0%)\n0 (0%)\n106 (44.5%)\n5 (13.9%)\n4 (10.8%)\n\n\nQ4\n0 (0%)\n0 (0%)\n53 (22.3%)\n29 (80.6%)\n33 (89.2%)\n\n\n\n\n\n\n\nCode\npercentineachbreakcategory &lt;- ICGI %&gt;% \n  group_by(DOSE) %&gt;% \n  mutate(Ntot= n())%&gt;% \n  group_by(DOSE,AUC_Q) %&gt;% \n  mutate(Ncat=n(),\n         xmed=median(AUC),xmin = min(AUC),\n         xmax = max(AUC), xmean = mean(c(xmin,xmax)))%&gt;% \n  mutate(percentage=Ncat/Ntot)%&gt;% \n  distinct(DOSE,AUC_Q,xmed,xmean, xmin, xmax,Ncat,Ntot,percentage) %&gt;% \n  arrange(DOSE,AUC_Q)\n\n\nWe then add this information to the ggridges plot using geom_density_ridges_gradient to color by quartile and using geom_text to add the percentages. We also show how to do it using geom_density and facet_grid.\n\n\nCode\nggplot(ICGI %&gt;% filter(AUC&gt;0),\n       aes(x = AUC, y = DOSE)) +\n  geom_density_ridges_gradient(aes(fill = after_stat(\n    case_when(x &lt;= q25 ~ \"Q1\",\n              x &gt; q25 & x &lt;= q50 ~ \"Q2\",\n              x &gt; q50 & x &lt;= q75 ~ \"Q3\",\n              x &gt; q75 ~ \"Q4\"))),\n    rel_min_height = 0.01,\n    quantile_lines = TRUE,\n    jittered_points = TRUE, alpha = 0.2, scale = 0.9)+\n  geom_vline(xintercept = AUCquantiles)+\n  geom_text_repel(data=percentineachbreakcategory %&gt;% \n                    filter(DOSE!=\"Placebo\"),\n                  aes(label=paste0(\"N =\",Ncat,\"\\n\",round(100*percentage,0),\"%\"),\n                      x=xmean, y =DOSE,size=4,\n                      color = AUC_Q ),vjust=1.2,\n            direction=\"x\",show.legend = FALSE)+\n  guides(fill = guide_legend(reverse = TRUE))+\n  scale_x_continuous(breaks= seq(0,400,50))+\n  theme_bw()+\n  labs(x=\"AUC (µg*h/mL)\",fill =\"\")+\n  scale_fill_manual(values=c(\"#4682AC70\", \"#FDBB2F70\", \"#EE312470\",\n                             \"#33634370\", \"#7059a670\", \"#80333370\"))+\n  scale_color_manual(values=c(\"#4682AC90\", \"#FDBB2F90\", \"#EE312490\",\n                             \"#33634390\", \"#7059a690\", \"#80333390\"))\n\n\n\n\n\n\n\n\n\nCode\nggplot(ICGI %&gt;% \n         filter(DOSE!=\"Placebo\"))+\n  geom_rug(aes(x = AUC,color = AUC_Q ) ,length = unit(0.2,\"cm\"))+\n  geom_density(aes(x = AUC,\n                   group = DOSE,\n                   y=after_stat(scaled),\n                   fill = after_stat(\n                     case_when(x &lt;= q25 ~ \"Q1\",\n                               x &gt; q25 & x &lt;= q50 ~ \"Q2\",\n                               x &gt; q50 & x &lt;= q75 ~ \"Q3\",\n                               x &gt; q75 ~ \"Q4\"))),alpha=0.3)+\n  geom_text_repel(data=percentineachbreakcategory %&gt;% \n                    filter(DOSE!=\"Placebo\"),\n                  aes(label=paste0(\"N =\",Ncat,\"\\n\",round(100*percentage,0),\"%\"),\n                      x=xmean, y =0,\n                      color = AUC_Q ),direction=\"y\",\n                  show.legend = FALSE)+\n  geom_text(data=percentineachbreakcategory %&gt;% \n              filter(DOSE!=\"Placebo\")%&gt;%\n              ungroup() %&gt;%\n              distinct(DOSE,Ntot),\n            aes(label=paste0(\"N tot = \",Ntot,\"\\n\\n\"),\n                x=300,y=0,\n            ))+\n  geom_vline(xintercept = c(q25,q50,q75))+\n  labs(fill=\"Quartiles\",color=\"Quartiles\")+\n  facet_grid(DOSE~.,as.table = FALSE,switch=\"y\")+\n  scale_fill_manual(values=c(\"#4682AC\", \n                             \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  scale_color_manual(values=c(\"#4682AC\", \n                              \"#FDBB2F\", \"#EE3124\", \"#336343\", \"#7059a6\", \"#803333\"))+\n  theme_bw()+\n  theme(strip.background = element_rect(fill = \"#475c6b\"),\n        strip.text.y.left =   element_text(face = \"bold\",\n                                           color = \"white\",angle=0),\n        strip.placement = \"outside\", axis.title.y.left = element_blank())\n\n\n\n\n\n\n\n\n\nThe plot above show us the N of patients and percentages by quartile at each dose level. At the 1800 mg dose, 81 % of patients were at the highest quartile versus 89% at the 2400 mg. We can appreciate that there is some saturation going on. For reference I will show again a plot done using ggresponseexpdist which automates this process when user specify the exposure_distribution_percent option.\n\n\nCode\nICGIERDATA &lt;- ICGI\nICGIERDATA$Endpoint &lt;- \"ICGI\"\nICGIERDATA$response &lt;- ICGIERDATA$ICGI \n\nggresponseexpdist(data = ICGIERDATA,\nmodel_type = \"logistic\",\nexposure_metrics = c(\"AUC\"),\nexposure_metric_split = \"quartile\",\nN_byexptile_ypos = \"with means\",\nmean_obs_bydose = TRUE,\nmean_obs_bydose_plac = FALSE,\nN_bydose_ypos = \"none\",\nmean_obs_bydose_text_size = 0,\nN_text_size = 3,\nexposure_distribution_percent = \"%\")"
  },
  {
    "objectID": "posts/randomizationtest/index.html",
    "href": "posts/randomizationtest/index.html",
    "title": "Randomization Tests",
    "section": "",
    "text": "In this post, I will cover a general, randomization-based methodology to compare models without assuming an a priori known distribution for the test statistic. A regular likelihood ratio test (LRT) comparing nested models will assume infinite data (asymptotic) and that the likelihood ratio has a χ² distribution with degrees of freedom equal to the number of parameters difference. Other common situations where the χ² distribution does not apply:\n\ntesting variance components for example comparing a model with random effect on a parameter versus a model without the random effect. The literature has shown that since the variance is on a boundary a χ² with a mixture of degrees of freedom of 0 and 1 applies. Simulation can help us figure out the weights and for simple linear mixed effects model solutions exist.\ncomparing models that are not nested like a model using different models for the effect of a covariate on a parameter for example power versus linear models. Or comparing a model with covariate on slope versus a covariate on intercept as shown below.\n\nFirst, we will simulate a small dataset of eight individuals with a random slope and intercept model to mimic the situation where the asymptotic assumptions might not hold:\n\n\nCode\nlibrary(lme4)       \nlibrary(ggplot2)\nlibrary(pbapply)\nlibrary(combinat)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(tidyverse)\n\nset.seed(031230)\nNID &lt;- 8\nIDtime &lt;- seq(0,10,1)\ntime &lt;-  rep(IDtime,NID)\nID &lt;- factor(rep(1:NID, each = length(IDtime)))\n\ncov &lt;-  sample(c(2,2,2,2,2,2,1,1), NID,replace = FALSE)\ncov &lt;- data.frame(ID=factor(1:NID),cov = cov)\nmodeldata &lt;- left_join(data.frame(ID=ID,time=time ),\n                       cov)\n\nmodeldata$slopepop &lt;- -2 *(1+(modeldata$cov==2)*2.5) \nmodeldata$slopeind &lt;- modeldata$slopepop +\n  rep(rnorm(NID,sd= 2*0.3)   ,each = length(IDtime))\nmodeldata$intpop   &lt;- 100+((modeldata$cov==2)*60)\nmodeldata$intind   &lt;- 100+((modeldata$cov==2)*60) +\n  rep(rnorm(NID,sd= 100*0.15),each = length(IDtime))\n\nmodeldata$contresponse   &lt;-  (modeldata$intind) + modeldata$slopeind *modeldata$time + rnorm(nrow(modeldata), sd = 0.3)\nggplot(modeldata,aes(time,contresponse))+\n  geom_line(aes(group=ID))+\n  geom_point()+\n  facet_grid(~cov,labeller=\"label_both\")+\n  labs(x=\"Time\",y=\"Response\",\n       caption=\"\")+\n  ggthemes::scale_color_tableau()+\n  theme_bw(base_size=18)\n\n\n\n\n\n\n\n\n\nThe plot above shows the response versus time split by covariate and we can see that the intercept and slope differ by covariate value and that we have a total of eight subjects with unbalance i.e. two IDs having covariate value of 1 and six IDs having a value of 2. Next, we fit a series linear mixed effects models.\n\nmodel0: base model no covariate\nmodel1: covariate on intercept\nmodel2: covariate on slope\nmodel3: covariate on both (true model)\n\n\n\nCode\nmodel0 &lt;- lmer(contresponse ~ time +\n                 (1 | ID) + (0+time | ID),\n               data=modeldata,\n               REML = FALSE)\nmodel1 &lt;- lmer(contresponse ~ time + cov +\n                 (1 | ID) + (0+time | ID),\n               data=modeldata,\n               REML = FALSE)\nmodel2 &lt;- lmer(contresponse ~ time + time:cov+\n                 (1 | ID) + (0+time | ID),\n               data=modeldata,\n               REML = FALSE)\n\nmodel3 &lt;- lmer(contresponse ~ time + time*cov+\n                 (1 | ID) + (0+time | ID),\n               data=modeldata,\n               REML = FALSE)\n  \n#anova(model3,model0)\n#anova(model1,model0)\nanova(model3,model2)\n\n\nData: modeldata\nModels:\nmodel2: contresponse ~ time + time:cov + (1 | ID) + (0 + time | ID)\nmodel3: contresponse ~ time + time * cov + (1 | ID) + (0 + time | ID)\n       npar    AIC    BIC  logLik -2*log(L)  Chisq Df Pr(&gt;Chisq)    \nmodel2    6 178.79 193.65 -83.395    166.79                         \nmodel3    7 169.14 186.48 -77.568    155.14 11.655  1  0.0006405 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\nanova(model2,model1)\n\n\nData: modeldata\nModels:\nmodel2: contresponse ~ time + time:cov + (1 | ID) + (0 + time | ID)\nmodel1: contresponse ~ time + cov + (1 | ID) + (0 + time | ID)\n       npar    AIC    BIC  logLik -2*log(L) Chisq Df Pr(&gt;Chisq)\nmodel2    6 178.79 193.65 -83.395    166.79                    \nmodel1    6 193.44 208.30 -90.717    181.44     0  0           \n\n\nCode\nlrt_stat       &lt;- as.numeric(2 * (logLik(model2) - logLik(model1)))\nlrt_stat_m2_m1 &lt;- lrt_stat\nlrt_stat_m2_m1\n\n\n[1] 14.64448\n\n\nCode\n#p_value__m2_m1 &lt;- pchisq(lrt_stat_m2_m1, df = 0??, lower.tail = FALSE)    \n\n\nWhen comparing model2 and model1 we have no p-value as the degrees of freedom are equal. The AIC is lower for model2 by 14.6 points suggesting it is better than model1.\nNext, we will use randomization/permutation procedure to build the null distribution for the likelihood difference and compute a p-value.\n\n\nCode\nn_permutations &lt;- 1000  # Number of permutations \nlrt_null_distribution &lt;- pbapply::pbreplicate(n_permutations, {\n  permcov &lt;- modeldata %&gt;%\n  distinct(ID,cov)%&gt;%\n  mutate(cov_permuted2= sample(cov,replace = FALSE))#\n  modeldataperm &lt;- left_join(modeldata,permcov)\n  model1_perm &lt;-  lmer(contresponse ~ time + cov_permuted2 +\n                 (1 | ID) + (0+time | ID),\n               data=modeldataperm,\n               REML = FALSE) \n  model2_perm &lt;- lmer(contresponse ~ time + time:cov_permuted2+\n                 (1 | ID) + (0+time | ID),\n                 data=modeldataperm,\n                 REML = FALSE)\n  as.numeric(2 * (logLik(model2_perm) - logLik(model1_perm)))\n})\n\np_value_permutation &lt;- mean(lrt_null_distribution &gt;= lrt_stat)\n\nggplot(data.frame(lrt=lrt_null_distribution,\nperm=1:length(lrt_null_distribution)),\n       aes(lrt)) +\n  geom_step(stat=\"ecdf\",aes(col=\"b.1000 permutations\"))+\n  geom_step(data=data.frame(lrt= rchisq(n = 10000, df = 1)),\n            stat=\"ecdf\",aes(col=\"a.theoretical\"))+\n  geom_hline(yintercept = 0.95)+\n  annotate(geom=\"text\", x = -1, y = 0.90, label=p_value_permutation)+\n  ggthemes::scale_color_tableau()+\n  theme_bw(base_size=16)+\n  theme(legend.position = \"top\")+\n  labs(col=\"\",x=\"Likelihood Difference\",\n       y=\"Empirical\\nCumulative Distribution \",\n       caption =\"a horizontal line is drawn at 95%\n       p-value: percentage of LRT values ≥ 14.64448\")+\n  scale_y_continuous(breaks= seq(0,1,0.2),\n                     labels = scales::percent_format())\n\n\n\n\n\n\n\n\n\nThe randomization test has shown that the model with covariate on slope is better than the model with covariate on intercept with a p-value of 0.03 which confirm the original data 14.65 points difference in -2LL. The procedure above randomly permuted the covariate values across the individuals a 1000 times. But wait a minute, we only have 8 subjects with 6 having covariate = 1 and 2 having covariate = 2 how many possible total permutation we have ? We will can compute that we have a total of 28 unique permutations and that we could have run the 28 models to have the full distribution of the LRT. This is what we are doing next !\n\n\nCode\nknitr::knit_hooks$set(crop = knitr::hook_pdfcrop)\n\ndata_vector &lt;- modeldata %&gt;% \n  distinct(ID,cov) %&gt;% \n  pull(cov)\nlist_of_permutations &lt;- combinat::permn(data_vector)\nmatrix_of_permutations &lt;- do.call(rbind, list_of_permutations)\nunique_permutations &lt;- unique(matrix_of_permutations)\n\npermdata&lt;- as.data.frame(unique_permutations) %&gt;%\nselect(ID1=V1,ID2=V2,ID3=V3,ID4=V4,ID5=V5,ID6=V6,ID7=V7,ID8=V8)%&gt;%\nmutate(permn=1:length(unique_permutations[,1])) %&gt;% \ngather(key,value,-permn)%&gt;% \narrange(permn)\n\nggplot(permdata,\naes(y=key,x=as.factor(permn),\nfill=as.factor(value)))+\ngeom_tile(col=\"black\")+\nlabs(fill=\"cov\",x = \"permutation number\")+\ncoord_equal()\n\n\n\n\n\n\n\n\n\nNext we do the permutation test using all possible permutations (N=28). It happens that permutation 1 has the same order of the original data we had.\n\n\nCode\nn_permutations &lt;- 28  \nlrt_null_distribution_all &lt;- NULL \nfor (i in 1:n_permutations) {\n  permcov &lt;- modeldata %&gt;%\n    distinct(ID,cov)%&gt;%\n    mutate(cov_permuted2= unique_permutations[i,])#\n  modeldataperm &lt;- left_join(modeldata,permcov)\n  model1_perm &lt;-  lmer(contresponse ~ time + cov_permuted2 +\n                 (1 | ID) + (0+time | ID),\n               data=modeldataperm,\n               REML = FALSE) \n  model2_perm &lt;- lmer(contresponse ~ time + time:cov_permuted2+\n                 (1 | ID) + (0+time | ID),\n                 data=modeldataperm,\n                 REML = FALSE)\n  as.numeric(2 * (logLik(model2_perm) - logLik(model1_perm)))\n  lrt_null_distribution_all[i] &lt;-as.numeric(2 * (logLik(model2_perm) - logLik(model1_perm)))\n}\n\np_value_permutation_all &lt;- mean(lrt_null_distribution_all &gt;= lrt_stat)\np_value_permutation_all\n\n\n[1] 0.03571429\n\n\nCode\nggplot(data.frame(lrt=lrt_null_distribution,\nperm=1:length(lrt_null_distribution)),\n       aes(lrt)) +\n  geom_step(stat=\"ecdf\",aes(col=\"b.1000 permutations\"))+\n  geom_step(data=data.frame(lrt=lrt_null_distribution_all),\nstat=\"ecdf\",aes(col=\"c.all permutations\"))+\ngeom_step(data=data.frame(lrt= rchisq(n = 10000, df = 1)),\n            stat=\"ecdf\",aes(col=\"a.theoretical\"))+\n  geom_hline(yintercept = 0.95)+\n  annotate(geom=\"text\", x = -1, y = 0.90, label= round(p_value_permutation_all,3))+\n  ggthemes::scale_color_tableau()+\n  theme_bw(base_size=16)+\n  theme(legend.position = \"top\")+\n    theme(legend.position = \"top\")+\n  labs(col=\"\",x=\"Likelihood Difference\",\n       y=\"Empirical\\nCumulative Distribution \",\n       caption =\"a horizontal line is drawn at 95%\n       p-value: percentage of LRT values ≥ 14.64448\")+\n  scale_y_continuous(breaks= seq(0,1,0.2),\n                     labels = scales::percent_format())\n\n\n\n\n\n\n\n\n\nThe plot shows that there is a good agreement between the random 1000 permutations versus the all permutations (N=28) approach. Ideally, one should not waste CPU and time when the full distribution can be simulated. In practice the number of possible permutation becomes quickly in the millions and billions so we resort to a random subset to approximate it.\nNow it is your turn, use the code provided in the post to compute p-values for removing random effect on slope!."
  }
]